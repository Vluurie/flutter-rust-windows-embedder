# A Rust-based Embedder for Flutter on Windows

This library is a highly experimental, not perfect or fully fully finished, Rust-based custom embedder for Flutter, originally created for an in-game world editor. Just shared for references or if it maybe helps someone, as saied i experimented with it. It is not intended for production use and has been tested primarily for its original use case.

It provides two modes of operation:

1.  **Standalone Runner**: Launches a Flutter application within a Rust executable, separate from a main application.
2.  **DirectX 11 Overlay**: Renders a Flutter UI to a D3D11 texture, allowing a host application to composite it into its own render pipeline.

**Example Use Case:**

![ezgif com-video-to-gif-converter(1)](https://github.com/user-attachments/assets/5d75d20e-d2f6-4407-a6c4-364e96a89b3e)


-----

## Features

  * Host Flutter applications within a Rust executable.
  * Dynamically load desktop plugins at runtime (standalone mode only).
  * Render UI to D3D11 textures with a full API for render and input management.
  * Provides a software renderer fallback and supports hardware-accelerated OpenGL via ANGLE.
  * Supports hybrid rendering of 2D widgets and 3D primitives.
  * Apply post-processing shaders to the Flutter UI or individual widgets.
  * Facilitates bi-directional Rust-Dart communication via send ports and platform channels. For complex data, consider using [flutter\_rust\_bridge](https://github.com/fzyzcjy/flutter_rust_bridge).

-----

## Mode 1: Standalone Launcher

### Setup

For the standalone launcher, a standard Flutter build is all that is required. The library automatically finds and uses the `flutter_windows.dll` generated by the build process.

1.  **Build Flutter Assets**:
    ```bash
    flutter build windows
    ```
2.  **File Placement**: Ensure the resulting build output (containing `flutter_windows.dll` and the `data` directory) is located where your Rust executable can find it (typically in the same directory).

### Usage

First, add the library to your `Cargo.toml`:

```toml
flutter_rust_windows_embedder = { git = "https://github.com/Vluurie/flutter-rust-windows-embedder.git", branch = "master" }
```

To run the Flutter application in a new window:

```rust
// Use `init_flutter_window_from_dir()` to specify a custom path.
init_flutter_window();
```

-----

## Mode 2: DirectX Overlay

### Setup

The DirectX overlay mode requires a specific version of the Flutter Engine and, for hardware acceleration, the ANGLE libraries.

1.  **Flutter Engine**: This mode requires `flutter_engine.dll` for version **3.29.3**.

      * **JIT (Debug)**: Download the JIT engine from the official Google Storage API release ZIP.
      * **AOT (Release)**: Compile the AOT engine yourself by following the [Custom Flutter Engine Embedding in AOT Mode](https://github.com/flutter/engine/blob/main/docs/Custom-Flutter-Engine-Embedding-in-AOT-Mode.md) guide.

2.  **ANGLE Libraries (Optional)**: For hardware acceleration, ANGLE is used for OpenGL to DirectX translation. This requires `libEGL.dll` and `libGLESv2.dll`. These can often be found in a local Google Chrome installation (e.g., `C:\Program Files\Google\Chrome\Application\{version}\`).

3.  **Flutter Assets**: Build your Flutter application assets using one of the following commands:

      * **Standard Build**:
        ```bash
        flutter build windows
        ```
      * **Assemble Command (Assets Only)**:
        ```bash
        flutter assemble --output=build -dTargetPlatform=windows-x64 -dBuildMode={build_mode} {build_mode}_bundle_windows-x64_assets
        ```

4.  **File Placement**: Place `flutter_engine.dll`, `libEGL.dll`, and `libGLESv2.dll` in the final asset directory alongside your Flutter assets. The library will locate them at runtime.

### Usage

First, add the library to your `Cargo.toml`:

```toml
flutter_rust_windows_embedder = { git = "https://github.com/Vluurie/flutter-rust-windows-embedder.git", branch = "master" }
```

To embed the Flutter UI as an overlay:

**1. Initialize an Overlay Instance**

```rust
use std::path::PathBuf;

let manager = get_flutter_overlay_manager_handle().unwrap();
let assets_path = PathBuf::from("./flutter_build");

// Creates and initializes a new Flutter overlay instance.
manager.init_instance(
    &my_dxgi_swap_chain, // The host application's IDXGISwapChain
    &assets_path,
    "main_hud",          // A unique identifier for this instance
    None,                // Optional: Dart main() arguments
    None,                // Optional: Flutter Engine arguments
);
```

**2. Render the UI**

In your application's main render loop (e.g., inside a hooked `Present` call), render the UI.

```rust
// Inside the main render loop...
manager.render_ui();
```

-----

## License

  * This crate is licensed under the **MIT License**. See [LICENSE](https://www.google.com/search?q=./LICENSE).
  * The Flutter engine and its C API bindings are licensed under the **BSD 3-Clause License**. See [LICENSE-THIRD-PARTY](https://www.google.com/search?q=./LICENSE-THIRD-PARTY).
