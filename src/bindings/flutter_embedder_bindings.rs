/* automatically generated by rust-bindgen 0.71.1 */

pub const FlutterEngineResult_kSuccess: FlutterEngineResult = 0;
pub const FlutterEngineResult_kInvalidLibraryVersion: FlutterEngineResult = 1;
pub const FlutterEngineResult_kInvalidArguments: FlutterEngineResult = 2;
pub const FlutterEngineResult_kInternalInconsistency: FlutterEngineResult = 3;
pub type FlutterEngineResult = ::std::os::raw::c_int;
pub const FlutterRendererType_kOpenGL: FlutterRendererType = 0;
pub const FlutterRendererType_kSoftware: FlutterRendererType = 1;
#[doc = " Metal is only supported on Darwin platforms (macOS / iOS).\n iOS version >= 10.0 (device), 13.0 (simulator)\n macOS version >= 10.14"]
pub const FlutterRendererType_kMetal: FlutterRendererType = 2;
#[doc = " Metal is only supported on Darwin platforms (macOS / iOS).\n iOS version >= 10.0 (device), 13.0 (simulator)\n macOS version >= 10.14"]
pub const FlutterRendererType_kVulkan: FlutterRendererType = 3;
pub type FlutterRendererType = ::std::os::raw::c_int;
#[doc = " The equivalent of a user briefly tapping the screen with the finger\n without moving it."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionTap: FlutterSemanticsAction = 1;
#[doc = " The equivalent of a user pressing and holding the screen with the finger\n for a few seconds without moving it."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionLongPress: FlutterSemanticsAction = 2;
#[doc = " The equivalent of a user moving their finger across the screen from right\n to left."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollLeft: FlutterSemanticsAction = 4;
#[doc = " The equivalent of a user moving their finger across the screen from left\n to\n right."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollRight: FlutterSemanticsAction = 8;
#[doc = " The equivalent of a user moving their finger across the screen from bottom\n to top."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollUp: FlutterSemanticsAction = 16;
#[doc = " The equivalent of a user moving their finger across the screen from top to\n bottom."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollDown: FlutterSemanticsAction = 32;
#[doc = " Increase the value represented by the semantics node."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionIncrease: FlutterSemanticsAction = 64;
#[doc = " Decrease the value represented by the semantics node."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDecrease: FlutterSemanticsAction = 128;
#[doc = " A request to fully show the semantics node on screen."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionShowOnScreen: FlutterSemanticsAction = 256;
#[doc = " Move the cursor forward by one character."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorForwardByCharacter:
    FlutterSemanticsAction = 512;
#[doc = " Move the cursor backward by one character."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorBackwardByCharacter:
    FlutterSemanticsAction = 1024;
#[doc = " Set the text selection to the given range."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionSetSelection: FlutterSemanticsAction = 2048;
#[doc = " Copy the current selection to the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCopy: FlutterSemanticsAction = 4096;
#[doc = " Cut the current selection and place it in the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCut: FlutterSemanticsAction = 8192;
#[doc = " Paste the current content of the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionPaste: FlutterSemanticsAction = 16384;
#[doc = " Indicate that the node has gained accessibility focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDidGainAccessibilityFocus:
    FlutterSemanticsAction = 32768;
#[doc = " Indicate that the node has lost accessibility focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDidLoseAccessibilityFocus:
    FlutterSemanticsAction = 65536;
#[doc = " Indicate that the user has invoked a custom accessibility action."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCustomAction: FlutterSemanticsAction =
    131072;
#[doc = " A request that the node should be dismissed."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDismiss: FlutterSemanticsAction = 262144;
#[doc = " Move the cursor forward by one word."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorForwardByWord:
    FlutterSemanticsAction = 524288;
#[doc = " Move the cursor backward by one word."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorBackwardByWord:
    FlutterSemanticsAction = 1048576;
#[doc = " Replace the current text in the text field."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionSetText: FlutterSemanticsAction = 2097152;
#[doc = " Request that the respective focusable widget gain input focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionFocus: FlutterSemanticsAction = 4194304;
#[doc = " Request that scrolls the current scrollable container to a given scroll\n offset."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollToOffset: FlutterSemanticsAction =
    8388608;
#[doc = " The set of possible actions that can be conveyed to a semantics node.\n\n Must match the `SemanticsAction` enum in semantics.dart."]
pub type FlutterSemanticsAction = ::std::os::raw::c_int;
#[doc = " The semantics node has the quality of either being \"checked\" or\n \"unchecked\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasCheckedState: FlutterSemanticsFlag = 1;
#[doc = " Whether a semantics node is checked."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsChecked: FlutterSemanticsFlag = 2;
#[doc = " Whether a semantics node is selected."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsSelected: FlutterSemanticsFlag = 4;
#[doc = " Whether the semantic node represents a button."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsButton: FlutterSemanticsFlag = 8;
#[doc = " Whether the semantic node represents a text field."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsTextField: FlutterSemanticsFlag = 16;
#[doc = " Whether the semantic node currently holds the user's focus."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsFocused: FlutterSemanticsFlag = 32;
#[doc = " The semantics node has the quality of either being \"enabled\" or\n \"disabled\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasEnabledState: FlutterSemanticsFlag = 64;
#[doc = " Whether a semantic node that hasEnabledState is currently enabled."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsEnabled: FlutterSemanticsFlag = 128;
#[doc = " Whether a semantic node is in a mutually exclusive group."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsInMutuallyExclusiveGroup:
    FlutterSemanticsFlag = 256;
#[doc = " Whether a semantic node is a header that divides content into sections."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsHeader: FlutterSemanticsFlag = 512;
#[doc = " Whether the value of the semantics node is obscured."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsObscured: FlutterSemanticsFlag = 1024;
#[doc = " Whether the semantics node is the root of a subtree for which a route name\n should be announced."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagScopesRoute: FlutterSemanticsFlag = 2048;
#[doc = " Whether the semantics node label is the name of a visually distinct route."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagNamesRoute: FlutterSemanticsFlag = 4096;
#[doc = " Whether the semantics node is considered hidden."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsHidden: FlutterSemanticsFlag = 8192;
#[doc = " Whether the semantics node represents an image."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsImage: FlutterSemanticsFlag = 16384;
#[doc = " Whether the semantics node is a live region."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsLiveRegion: FlutterSemanticsFlag = 32768;
#[doc = " The semantics node has the quality of either being \"on\" or \"off\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasToggledState: FlutterSemanticsFlag = 65536;
#[doc = " If true, the semantics node is \"on\". If false, the semantics node is\n \"off\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsToggled: FlutterSemanticsFlag = 131072;
#[doc = " Whether the platform can scroll the semantics node when the user attempts\n to move the accessibility focus to an offscreen child.\n\n For example, a `ListView` widget has implicit scrolling so that users can\n easily move the accessibility focus to the next set of children. A\n `PageView` widget does not have implicit scrolling, so that users don't\n navigate to the next page when reaching the end of the current one."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasImplicitScrolling: FlutterSemanticsFlag =
    262144;
#[doc = " Whether the value of the semantics node is coming from a multi-line text\n field.\n\n This is used for text fields to distinguish single-line text fields from\n multi-line ones."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsMultiline: FlutterSemanticsFlag = 524288;
#[doc = " Whether the semantic node is read only.\n\n Only applicable when kFlutterSemanticsFlagIsTextField flag is on."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsReadOnly: FlutterSemanticsFlag = 1048576;
#[doc = " Whether the semantic node can hold the user's focus."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsFocusable: FlutterSemanticsFlag = 2097152;
#[doc = " Whether the semantics node represents a link."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsLink: FlutterSemanticsFlag = 4194304;
#[doc = " Whether the semantics node represents a slider."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsSlider: FlutterSemanticsFlag = 8388608;
#[doc = " Whether the semantics node represents a keyboard key."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsKeyboardKey: FlutterSemanticsFlag = 16777216;
#[doc = " Whether the semantics node represents a tristate checkbox in mixed state."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsCheckStateMixed: FlutterSemanticsFlag =
    33554432;
#[doc = " The semantics node has the quality of either being \"expanded\" or\n \"collapsed\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasExpandedState: FlutterSemanticsFlag =
    67108864;
#[doc = " Whether a semantic node that hasExpandedState is currently expanded."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsExpanded: FlutterSemanticsFlag = 134217728;
#[doc = " The semantics node has the quality of either being \"selected\" or\n \"not selected\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasSelectedState: FlutterSemanticsFlag =
    268435456;
#[doc = " The set of properties that may be associated with a semantics node.\n\n Must match the `SemanticsFlag` enum in semantics.dart."]
pub type FlutterSemanticsFlag = ::std::os::raw::c_int;
#[doc = " Text has unknown text direction."]
pub const FlutterTextDirection_kFlutterTextDirectionUnknown: FlutterTextDirection = 0;
#[doc = " Text is read from right to left."]
pub const FlutterTextDirection_kFlutterTextDirectionRTL: FlutterTextDirection = 1;
#[doc = " Text is read from left to right."]
pub const FlutterTextDirection_kFlutterTextDirectionLTR: FlutterTextDirection = 2;
pub type FlutterTextDirection = ::std::os::raw::c_int;
#[doc = " Suitable for threads that shouldn't disrupt high priority work."]
pub const FlutterThreadPriority_kBackground: FlutterThreadPriority = 0;
#[doc = " Default priority level."]
pub const FlutterThreadPriority_kNormal: FlutterThreadPriority = 1;
#[doc = " Suitable for threads which generate data for the display."]
pub const FlutterThreadPriority_kDisplay: FlutterThreadPriority = 2;
#[doc = " Suitable for thread which raster data."]
pub const FlutterThreadPriority_kRaster: FlutterThreadPriority = 3;
#[doc = " Valid values for priority of Thread."]
pub type FlutterThreadPriority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterEngine {
    _unused: [u8; 0],
}
pub type FlutterEngine = *mut _FlutterEngine;
#[doc = " Unique identifier for views.\n\n View IDs are generated by the embedder and are\n opaque to the engine; the engine does not interpret view IDs in any way."]
pub type FlutterViewId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterTransformation {
    #[doc = " horizontal scale factor"]
    pub scaleX: f64,
    #[doc = " horizontal skew factor"]
    pub skewX: f64,
    #[doc = " horizontal translation"]
    pub transX: f64,
    #[doc = " vertical skew factor"]
    pub skewY: f64,
    #[doc = " vertical scale factor"]
    pub scaleY: f64,
    #[doc = " vertical translation"]
    pub transY: f64,
    #[doc = " input x-axis perspective factor"]
    pub pers0: f64,
    #[doc = " input y-axis perspective factor"]
    pub pers1: f64,
    #[doc = " perspective scale factor"]
    pub pers2: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTransformation"][::std::mem::size_of::<FlutterTransformation>() - 72usize];
    ["Alignment of FlutterTransformation"]
        [::std::mem::align_of::<FlutterTransformation>() - 8usize];
    ["Offset of field: FlutterTransformation::scaleX"]
        [::std::mem::offset_of!(FlutterTransformation, scaleX) - 0usize];
    ["Offset of field: FlutterTransformation::skewX"]
        [::std::mem::offset_of!(FlutterTransformation, skewX) - 8usize];
    ["Offset of field: FlutterTransformation::transX"]
        [::std::mem::offset_of!(FlutterTransformation, transX) - 16usize];
    ["Offset of field: FlutterTransformation::skewY"]
        [::std::mem::offset_of!(FlutterTransformation, skewY) - 24usize];
    ["Offset of field: FlutterTransformation::scaleY"]
        [::std::mem::offset_of!(FlutterTransformation, scaleY) - 32usize];
    ["Offset of field: FlutterTransformation::transY"]
        [::std::mem::offset_of!(FlutterTransformation, transY) - 40usize];
    ["Offset of field: FlutterTransformation::pers0"]
        [::std::mem::offset_of!(FlutterTransformation, pers0) - 48usize];
    ["Offset of field: FlutterTransformation::pers1"]
        [::std::mem::offset_of!(FlutterTransformation, pers1) - 56usize];
    ["Offset of field: FlutterTransformation::pers2"]
        [::std::mem::offset_of!(FlutterTransformation, pers2) - 64usize];
};
pub type VoidCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Specifies an OpenGL texture target type. Textures are specified using\n the FlutterOpenGLTexture struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeTexture: FlutterOpenGLTargetType = 0;
#[doc = " Specifies an OpenGL frame-buffer target type. Framebuffers are specified\n using the FlutterOpenGLFramebuffer struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeFramebuffer: FlutterOpenGLTargetType = 1;
#[doc = " Specifies an OpenGL on-screen surface target type. Surfaces are specified\n using the FlutterOpenGLSurface struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeSurface: FlutterOpenGLTargetType = 2;
pub type FlutterOpenGLTargetType = ::std::os::raw::c_int;
#[doc = " Pixel with 8 bit grayscale value.\n The grayscale value is the luma value calculated from r, g, b\n according to BT.709. (gray = r*0.2126 + g*0.7152 + b*0.0722)"]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatGray8: FlutterSoftwarePixelFormat =
    0;
#[doc = " Pixel with 5 bits red, 6 bits green, 5 bits blue, in 16-bit word.\n   r = (p >> 11) & 0x1F;\n   g = (p >> 5) & 0x3F;\n   b = p & 0x1F;\n\n On most (== little-endian) systems, this is equivalent to wayland format\n RGB565 (WL_DRM_FORMAT_RGB565, WL_SHM_FORMAT_RGB565)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGB565: FlutterSoftwarePixelFormat =
    1;
#[doc = " Pixel with 4 bits each for alpha, red, green, blue; in 16-bit word.\n   r = (p >> 8) & 0xF;\n   g = (p >> 4) & 0xF;\n   b = p & 0xF;\n   a = (p >> 12) & 0xF;\n\n On most (== little-endian) systems, this is equivalent to wayland format\n RGBA4444 (WL_DRM_FORMAT_RGBA4444, WL_SHM_FORMAT_RGBA4444)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBA4444:
    FlutterSoftwarePixelFormat = 2;
#[doc = " Pixel with 8 bits each for red, green, blue, alpha.\n   r = p[0];\n   g = p[1];\n   b = p[2];\n   a = p[3];\n\n This is equivalent to wayland format ABGR8888 (WL_DRM_FORMAT_ABGR8888,\n WL_SHM_FORMAT_ABGR8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBA8888:
    FlutterSoftwarePixelFormat = 3;
#[doc = " Pixel with 8 bits each for red, green and blue and 8 unused bits.\n   r = p[0];\n   g = p[1];\n   b = p[2];\n\n This is equivalent to wayland format XBGR8888 (WL_DRM_FORMAT_XBGR8888,\n WL_SHM_FORMAT_XBGR8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBX8888:
    FlutterSoftwarePixelFormat = 4;
#[doc = " Pixel with 8 bits each for blue, green, red and alpha.\n   r = p[2];\n   g = p[1];\n   b = p[0];\n   a = p[3];\n\n This is equivalent to wayland format ARGB8888 (WL_DRM_FORMAT_ARGB8888,\n WL_SHM_FORMAT_ARGB8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatBGRA8888:
    FlutterSoftwarePixelFormat = 5;
#[doc = " Either kFlutterSoftwarePixelFormatBGRA8888 or\n kFlutterSoftwarePixelFormatRGBA8888 depending on CPU endianess and OS."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatNative32:
    FlutterSoftwarePixelFormat = 6;
#[doc = " A pixel format to be used for software rendering.\n\n A single pixel always stored as a POT number of bytes. (so in practice\n either 1, 2, 4, 8, 16 bytes per pixel)\n\n There are two kinds of pixel formats:\n   - formats where all components are 8 bits, called array formats\n     The component order as specified in the pixel format name is the\n     order of the components' bytes in memory, with the leftmost component\n     occupying the lowest memory address.\n\n   - all other formats are called packed formats, and the component order\n     as specified in the format name refers to the order from most\n     significant to least significant bits in the native type. for example,\n     for kFlutterSoftwarePixelFormatRGB565, R occupies the 5 most significant\n     bits, G the middle 6 bits, and B the 5 least significant bits.\n\n Each pixel format in this list is documented with an example on how to get\n the color components from the pixel.\n - for packed formats, p is the pixel value as a word. For example, you can\n   get the pixel value for a RGB565 formatted buffer like this:\n   uint16_t p = ((const uint16_t*) allocation)[row_bytes * y / bpp + x];\n   (with bpp being the bytes per pixel, so 2 for RGB565)\n\n - for array formats, p is a pointer to the pixel value. For example, you\n   can get the p for a RGBA8888 formatted buffer like this:\n   const uint8_t *p = ((const uint8_t*) allocation) + row_bytes*y + x*4;"]
pub type FlutterSoftwarePixelFormat = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLTexture {
    #[doc = " Target texture of the active texture unit (example GL_TEXTURE_2D or\n GL_TEXTURE_RECTANGLE)."]
    pub target: u32,
    #[doc = " The name of the texture."]
    pub name: u32,
    #[doc = " The texture format (example GL_RGBA8)."]
    pub format: u32,
    #[doc = " User data to be returned on the invocation of the destruction callback."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine managed thread) that asks the embedder to\n collect the texture."]
    pub destruction_callback: VoidCallback,
    #[doc = " Optional parameters for texture height/width, default is 0, non-zero means\n the texture has the specified width/height. Usually, when the texture type\n is GL_TEXTURE_RECTANGLE, we need to specify the texture width/height to\n tell the embedder to scale when rendering.\n Width of the texture."]
    pub width: usize,
    #[doc = " Height of the texture."]
    pub height: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLTexture"][::std::mem::size_of::<FlutterOpenGLTexture>() - 48usize];
    ["Alignment of FlutterOpenGLTexture"][::std::mem::align_of::<FlutterOpenGLTexture>() - 8usize];
    ["Offset of field: FlutterOpenGLTexture::target"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, target) - 0usize];
    ["Offset of field: FlutterOpenGLTexture::name"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, name) - 4usize];
    ["Offset of field: FlutterOpenGLTexture::format"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, format) - 8usize];
    ["Offset of field: FlutterOpenGLTexture::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, user_data) - 16usize];
    ["Offset of field: FlutterOpenGLTexture::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, destruction_callback) - 24usize];
    ["Offset of field: FlutterOpenGLTexture::width"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, width) - 32usize];
    ["Offset of field: FlutterOpenGLTexture::height"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, height) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLFramebuffer {
    #[doc = " The format of the color attachment of the frame-buffer. For example,\n GL_RGBA8.\n\n In case of ambiguity when dealing with Window bound frame-buffers, 0 may\n be used.\n\n @bug      This field is incorrectly named as \"target\" when it actually\n           refers to a format."]
    pub target: u32,
    #[doc = " The name of the framebuffer."]
    pub name: u32,
    #[doc = " User data to be returned on the invocation of the destruction callback."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine managed thread) that asks the embedder to\n collect the framebuffer."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLFramebuffer"]
        [::std::mem::size_of::<FlutterOpenGLFramebuffer>() - 24usize];
    ["Alignment of FlutterOpenGLFramebuffer"]
        [::std::mem::align_of::<FlutterOpenGLFramebuffer>() - 8usize];
    ["Offset of field: FlutterOpenGLFramebuffer::target"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, target) - 0usize];
    ["Offset of field: FlutterOpenGLFramebuffer::name"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, name) - 4usize];
    ["Offset of field: FlutterOpenGLFramebuffer::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, user_data) - 8usize];
    ["Offset of field: FlutterOpenGLFramebuffer::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, destruction_callback) - 16usize];
};
pub type FlutterOpenGLSurfaceCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut bool) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLSurface {
    #[doc = " The size of this struct. Must be sizeof(FlutterOpenGLSurface)."]
    pub struct_size: usize,
    #[doc = " User data to be passed to the make_current, clear_current and\n destruction callbacks."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine-managed thread) that asks the embedder to\n make the surface current.\n\n Should return true if the operation succeeded, false if the surface could\n not be made current and rendering should be cancelled.\n\n The second parameter 'opengl state changed' should be set to true if\n any OpenGL API state is different than before this callback was called.\n In that case, Flutter will invalidate the internal OpenGL API state cache,\n which is a somewhat expensive operation.\n\n @attention required. (non-null)"]
    pub make_current_callback: FlutterOpenGLSurfaceCallback,
    #[doc = " Callback invoked (on an engine-managed thread) when the current surface\n can be cleared.\n\n Should return true if the operation succeeded, false if an error ocurred.\n That error will be logged but otherwise not handled by the engine.\n\n The second parameter 'opengl state changed' is the same as with the\n @ref make_current_callback.\n\n The embedder might clear the surface here after it was previously made\n current. That's not required however, it's also possible to clear it in\n the destruction callback. There's no way to signal OpenGL state\n changes in the destruction callback though.\n\n @attention required. (non-null)"]
    pub clear_current_callback: FlutterOpenGLSurfaceCallback,
    #[doc = " Callback invoked (on an engine-managed thread) that asks the embedder to\n collect the surface.\n\n @attention required. (non-null)"]
    pub destruction_callback: VoidCallback,
    #[doc = " The surface format.\n\n Allowed values:\n   - GL_RGBA8\n   - GL_BGRA8_EXT"]
    pub format: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLSurface"][::std::mem::size_of::<FlutterOpenGLSurface>() - 48usize];
    ["Alignment of FlutterOpenGLSurface"][::std::mem::align_of::<FlutterOpenGLSurface>() - 8usize];
    ["Offset of field: FlutterOpenGLSurface::struct_size"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, struct_size) - 0usize];
    ["Offset of field: FlutterOpenGLSurface::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, user_data) - 8usize];
    ["Offset of field: FlutterOpenGLSurface::make_current_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, make_current_callback) - 16usize];
    ["Offset of field: FlutterOpenGLSurface::clear_current_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, clear_current_callback) - 24usize];
    ["Offset of field: FlutterOpenGLSurface::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, destruction_callback) - 32usize];
    ["Offset of field: FlutterOpenGLSurface::format"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, format) - 40usize];
};
pub type BoolCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> bool>;
pub type TransformationCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> FlutterTransformation,
>;
pub type UIntCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> u32>;
pub type SoftwareSurfacePresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
    ) -> bool,
>;
pub type ProcResolver = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type TextureFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: i64,
        arg3: usize,
        arg4: usize,
        arg5: *mut FlutterOpenGLTexture,
    ) -> bool,
>;
pub type VsyncCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: isize)>;
pub type OnPreEngineRestartCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " A structure to represent the width and height."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSize {
    pub width: f64,
    pub height: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSize"][::std::mem::size_of::<FlutterSize>() - 16usize];
    ["Alignment of FlutterSize"][::std::mem::align_of::<FlutterSize>() - 8usize];
    ["Offset of field: FlutterSize::width"][::std::mem::offset_of!(FlutterSize, width) - 0usize];
    ["Offset of field: FlutterSize::height"][::std::mem::offset_of!(FlutterSize, height) - 8usize];
};
#[doc = " A structure to represent the width and height.\n\n See: \\ref FlutterSize when the value are not integers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterUIntSize {
    pub width: u32,
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterUIntSize"][::std::mem::size_of::<FlutterUIntSize>() - 8usize];
    ["Alignment of FlutterUIntSize"][::std::mem::align_of::<FlutterUIntSize>() - 4usize];
    ["Offset of field: FlutterUIntSize::width"]
        [::std::mem::offset_of!(FlutterUIntSize, width) - 0usize];
    ["Offset of field: FlutterUIntSize::height"]
        [::std::mem::offset_of!(FlutterUIntSize, height) - 4usize];
};
#[doc = " A structure to represent a rectangle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRect {
    pub left: f64,
    pub top: f64,
    pub right: f64,
    pub bottom: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRect"][::std::mem::size_of::<FlutterRect>() - 32usize];
    ["Alignment of FlutterRect"][::std::mem::align_of::<FlutterRect>() - 8usize];
    ["Offset of field: FlutterRect::left"][::std::mem::offset_of!(FlutterRect, left) - 0usize];
    ["Offset of field: FlutterRect::top"][::std::mem::offset_of!(FlutterRect, top) - 8usize];
    ["Offset of field: FlutterRect::right"][::std::mem::offset_of!(FlutterRect, right) - 16usize];
    ["Offset of field: FlutterRect::bottom"][::std::mem::offset_of!(FlutterRect, bottom) - 24usize];
};
#[doc = " A structure to represent a 2D point."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPoint {
    pub x: f64,
    pub y: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPoint"][::std::mem::size_of::<FlutterPoint>() - 16usize];
    ["Alignment of FlutterPoint"][::std::mem::align_of::<FlutterPoint>() - 8usize];
    ["Offset of field: FlutterPoint::x"][::std::mem::offset_of!(FlutterPoint, x) - 0usize];
    ["Offset of field: FlutterPoint::y"][::std::mem::offset_of!(FlutterPoint, y) - 8usize];
};
#[doc = " A structure to represent a rounded rectangle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRoundedRect {
    pub rect: FlutterRect,
    pub upper_left_corner_radius: FlutterSize,
    pub upper_right_corner_radius: FlutterSize,
    pub lower_right_corner_radius: FlutterSize,
    pub lower_left_corner_radius: FlutterSize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRoundedRect"][::std::mem::size_of::<FlutterRoundedRect>() - 96usize];
    ["Alignment of FlutterRoundedRect"][::std::mem::align_of::<FlutterRoundedRect>() - 8usize];
    ["Offset of field: FlutterRoundedRect::rect"]
        [::std::mem::offset_of!(FlutterRoundedRect, rect) - 0usize];
    ["Offset of field: FlutterRoundedRect::upper_left_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, upper_left_corner_radius) - 32usize];
    ["Offset of field: FlutterRoundedRect::upper_right_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, upper_right_corner_radius) - 48usize];
    ["Offset of field: FlutterRoundedRect::lower_right_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, lower_right_corner_radius) - 64usize];
    ["Offset of field: FlutterRoundedRect::lower_left_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, lower_left_corner_radius) - 80usize];
};
#[doc = " A structure to represent a damage region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterDamage {
    #[doc = " The size of this struct. Must be sizeof(FlutterDamage)."]
    pub struct_size: usize,
    #[doc = " The number of rectangles within the damage region."]
    pub num_rects: usize,
    #[doc = " The actual damage region(s) in question."]
    pub damage: *mut FlutterRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterDamage"][::std::mem::size_of::<FlutterDamage>() - 24usize];
    ["Alignment of FlutterDamage"][::std::mem::align_of::<FlutterDamage>() - 8usize];
    ["Offset of field: FlutterDamage::struct_size"]
        [::std::mem::offset_of!(FlutterDamage, struct_size) - 0usize];
    ["Offset of field: FlutterDamage::num_rects"]
        [::std::mem::offset_of!(FlutterDamage, num_rects) - 8usize];
    ["Offset of field: FlutterDamage::damage"]
        [::std::mem::offset_of!(FlutterDamage, damage) - 16usize];
};
#[doc = " This information is passed to the embedder when requesting a frame buffer\n object.\n\n See: \\ref FlutterOpenGLRendererConfig.fbo_with_frame_info_callback,\n \\ref FlutterMetalRendererConfig.get_next_drawable_callback,\n and \\ref FlutterVulkanRendererConfig.get_next_image_callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterFrameInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterFrameInfo)."]
    pub struct_size: usize,
    #[doc = " The size of the surface that will be backed by the fbo."]
    pub size: FlutterUIntSize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterFrameInfo"][::std::mem::size_of::<FlutterFrameInfo>() - 16usize];
    ["Alignment of FlutterFrameInfo"][::std::mem::align_of::<FlutterFrameInfo>() - 8usize];
    ["Offset of field: FlutterFrameInfo::struct_size"]
        [::std::mem::offset_of!(FlutterFrameInfo, struct_size) - 0usize];
    ["Offset of field: FlutterFrameInfo::size"]
        [::std::mem::offset_of!(FlutterFrameInfo, size) - 8usize];
};
#[doc = " Callback for when a frame buffer object is requested."]
pub type UIntFrameInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const FlutterFrameInfo) -> u32,
>;
#[doc = " Callback for when a frame buffer object is requested with necessary\n information for partial repaint."]
pub type FlutterFrameBufferWithDamageCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: isize, arg3: *mut FlutterDamage),
>;
#[doc = " This information is passed to the embedder when a surface is presented.\n\n See: \\ref FlutterOpenGLRendererConfig.present_with_info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPresentInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterPresentInfo)."]
    pub struct_size: usize,
    #[doc = " Id of the fbo backing the surface that was presented."]
    pub fbo_id: u32,
    #[doc = " Damage representing the area that the compositor needs to render."]
    pub frame_damage: FlutterDamage,
    #[doc = " Damage used to set the buffer's damage region."]
    pub buffer_damage: FlutterDamage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPresentInfo"][::std::mem::size_of::<FlutterPresentInfo>() - 64usize];
    ["Alignment of FlutterPresentInfo"][::std::mem::align_of::<FlutterPresentInfo>() - 8usize];
    ["Offset of field: FlutterPresentInfo::struct_size"]
        [::std::mem::offset_of!(FlutterPresentInfo, struct_size) - 0usize];
    ["Offset of field: FlutterPresentInfo::fbo_id"]
        [::std::mem::offset_of!(FlutterPresentInfo, fbo_id) - 8usize];
    ["Offset of field: FlutterPresentInfo::frame_damage"]
        [::std::mem::offset_of!(FlutterPresentInfo, frame_damage) - 16usize];
    ["Offset of field: FlutterPresentInfo::buffer_damage"]
        [::std::mem::offset_of!(FlutterPresentInfo, buffer_damage) - 40usize];
};
#[doc = " Callback for when a surface is presented."]
pub type BoolPresentInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterPresentInfo,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterOpenGLRendererConfig)."]
    pub struct_size: usize,
    pub make_current: BoolCallback,
    pub clear_current: BoolCallback,
    #[doc = " Specifying one (and only one) of `present` or `present_with_info` is\n required. Specifying both is an error and engine initialization will be\n terminated. The return value indicates success of the present call. If\n the intent is to use dirty region management, present_with_info must be\n defined as present will not succeed in communicating information about\n damage."]
    pub present: BoolCallback,
    #[doc = " Specifying one (and only one) of the `fbo_callback` or\n `fbo_with_frame_info_callback` is required. Specifying both is an error\n and engine intialization will be terminated. The return value indicates\n the id of the frame buffer object that flutter will obtain the gl surface\n from."]
    pub fbo_callback: UIntCallback,
    #[doc = " This is an optional callback. Flutter will ask the emebdder to create a GL\n context current on a background thread. If the embedder is able to do so,\n Flutter will assume that this context is in the same sharegroup as the\n main rendering context and use this context for asynchronous texture\n uploads. Though optional, it is recommended that all embedders set this\n callback as it will lead to better performance in texture handling."]
    pub make_resource_current: BoolCallback,
    #[doc = " By default, the renderer config assumes that the FBO does not change for\n the duration of the engine run. If this argument is true, the\n engine will ask the embedder for an updated FBO target (via an\n fbo_callback invocation) after a present call."]
    pub fbo_reset_after_present: bool,
    #[doc = " The transformation to apply to the render target before any rendering\n operations. This callback is optional.\n @attention      When using a custom compositor, the layer offset and sizes\n                 will be affected by this transformation. It will be\n                 embedder responsibility to render contents at the\n                 transformed offset and size. This is useful for embedders\n                 that want to render transformed contents directly into\n                 hardware overlay planes without having to apply extra\n                 transformations to layer contents (which may necessitate\n                 an expensive off-screen render pass)."]
    pub surface_transformation: TransformationCallback,
    pub gl_proc_resolver: ProcResolver,
    #[doc = " When the embedder specifies that a texture has a frame available, the\n engine will call this method (on an internal engine managed thread) so\n that external texture details can be supplied to the engine for subsequent\n composition."]
    pub gl_external_texture_frame_callback: TextureFrameCallback,
    #[doc = " Specifying one (and only one) of the `fbo_callback` or\n `fbo_with_frame_info_callback` is required. Specifying both is an error\n and engine intialization will be terminated. The return value indicates\n the id of the frame buffer object (fbo) that flutter will obtain the gl\n surface from. When using this variant, the embedder is passed a\n `FlutterFrameInfo` struct that indicates the properties of the surface\n that flutter will acquire from the returned fbo."]
    pub fbo_with_frame_info_callback: UIntFrameInfoCallback,
    #[doc = " Specifying one (and only one) of `present` or `present_with_info` is\n required. Specifying both is an error and engine initialization will be\n terminated. When using this variant, the embedder is passed a\n `FlutterPresentInfo` struct that the embedder can use to release any\n resources. The return value indicates success of the present call. This\n callback is essential for dirty region management. If not defined, all the\n pixels on the screen will be rendered at every frame (regardless of\n whether damage is actually being computed or not). This is because the\n information that is passed along to the callback contains the frame and\n buffer damage that are essential for dirty region management."]
    pub present_with_info: BoolPresentInfoCallback,
    #[doc = " Specifying this callback is a requirement for dirty region management.\n Dirty region management will only render the areas of the screen that have\n changed in between frames, greatly reducing rendering times and energy\n consumption. To take advantage of these benefits, it is necessary to\n define populate_existing_damage as a callback that takes user\n data, an FBO ID, and an existing damage FlutterDamage. The callback should\n use the given FBO ID to identify the FBO's exisiting damage (i.e. areas\n that have changed since the FBO was last used) and use it to populate the\n given existing damage variable. This callback is dependent on either\n fbo_callback or fbo_with_frame_info_callback being defined as they are\n responsible for providing populate_existing_damage with the FBO's\n ID. Not specifying populate_existing_damage will result in full\n repaint (i.e. rendering all the pixels on the screen at every frame)."]
    pub populate_existing_damage: FlutterFrameBufferWithDamageCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLRendererConfig"]
        [::std::mem::size_of::<FlutterOpenGLRendererConfig>() - 104usize];
    ["Alignment of FlutterOpenGLRendererConfig"]
        [::std::mem::align_of::<FlutterOpenGLRendererConfig>() - 8usize];
    ["Offset of field: FlutterOpenGLRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterOpenGLRendererConfig::make_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, make_current) - 8usize];
    ["Offset of field: FlutterOpenGLRendererConfig::clear_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, clear_current) - 16usize];
    ["Offset of field: FlutterOpenGLRendererConfig::present"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, present) - 24usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_callback"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, fbo_callback) - 32usize];
    ["Offset of field: FlutterOpenGLRendererConfig::make_resource_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, make_resource_current) - 40usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_reset_after_present"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, fbo_reset_after_present) - 48usize];
    ["Offset of field: FlutterOpenGLRendererConfig::surface_transformation"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, surface_transformation) - 56usize];
    ["Offset of field: FlutterOpenGLRendererConfig::gl_proc_resolver"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, gl_proc_resolver) - 64usize];
    ["Offset of field: FlutterOpenGLRendererConfig::gl_external_texture_frame_callback"][::std::mem::offset_of!(
        FlutterOpenGLRendererConfig,
        gl_external_texture_frame_callback
    )
        - 72usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_with_frame_info_callback"][::std::mem::offset_of!(
        FlutterOpenGLRendererConfig,
        fbo_with_frame_info_callback
    ) - 80usize];
    ["Offset of field: FlutterOpenGLRendererConfig::present_with_info"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, present_with_info) - 88usize];
    ["Offset of field: FlutterOpenGLRendererConfig::populate_existing_damage"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, populate_existing_damage) - 96usize];
};
#[doc = " Alias for id<MTLDevice>."]
pub type FlutterMetalDeviceHandle = *const ::std::os::raw::c_void;
#[doc = " Alias for id<MTLCommandQueue>."]
pub type FlutterMetalCommandQueueHandle = *const ::std::os::raw::c_void;
#[doc = " Alias for id<MTLTexture>."]
pub type FlutterMetalTextureHandle = *const ::std::os::raw::c_void;
pub const FlutterMetalExternalTexturePixelFormat_kYUVA: FlutterMetalExternalTexturePixelFormat = 0;
pub const FlutterMetalExternalTexturePixelFormat_kRGBA: FlutterMetalExternalTexturePixelFormat = 1;
#[doc = " Pixel format for the external texture."]
pub type FlutterMetalExternalTexturePixelFormat = ::std::os::raw::c_int;
pub const FlutterMetalExternalTextureYUVColorSpace_kBT601FullRange:
    FlutterMetalExternalTextureYUVColorSpace = 0;
pub const FlutterMetalExternalTextureYUVColorSpace_kBT601LimitedRange:
    FlutterMetalExternalTextureYUVColorSpace = 1;
#[doc = " YUV color space for the YUV external texture."]
pub type FlutterMetalExternalTextureYUVColorSpace = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalExternalTexture {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalExternalTexture)."]
    pub struct_size: usize,
    #[doc = " Height of the texture."]
    pub width: usize,
    #[doc = " Height of the texture."]
    pub height: usize,
    #[doc = " The pixel format type of the external."]
    pub pixel_format: FlutterMetalExternalTexturePixelFormat,
    #[doc = " Represents the size of the `textures` array."]
    pub num_textures: usize,
    #[doc = " Supported textures are YUVA and RGBA, in case of YUVA we expect 2 texture\n handles to be provided by the embedder, Y first and UV next. In case of\n RGBA only one should be passed.\n These are individually aliases for id<MTLTexture>. These textures are\n retained by the engine for the period of the composition. Once these\n textures have been unregistered via the\n `FlutterEngineUnregisterExternalTexture`, the embedder has to release\n these textures."]
    pub textures: *mut FlutterMetalTextureHandle,
    #[doc = " The YUV color space of the YUV external texture."]
    pub yuv_color_space: FlutterMetalExternalTextureYUVColorSpace,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalExternalTexture"]
        [::std::mem::size_of::<FlutterMetalExternalTexture>() - 56usize];
    ["Alignment of FlutterMetalExternalTexture"]
        [::std::mem::align_of::<FlutterMetalExternalTexture>() - 8usize];
    ["Offset of field: FlutterMetalExternalTexture::struct_size"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, struct_size) - 0usize];
    ["Offset of field: FlutterMetalExternalTexture::width"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, width) - 8usize];
    ["Offset of field: FlutterMetalExternalTexture::height"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, height) - 16usize];
    ["Offset of field: FlutterMetalExternalTexture::pixel_format"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, pixel_format) - 24usize];
    ["Offset of field: FlutterMetalExternalTexture::num_textures"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, num_textures) - 32usize];
    ["Offset of field: FlutterMetalExternalTexture::textures"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, textures) - 40usize];
    ["Offset of field: FlutterMetalExternalTexture::yuv_color_space"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, yuv_color_space) - 48usize];
};
#[doc = " Callback to provide an external texture for a given texture_id.\n See: external_texture_frame_callback."]
pub type FlutterMetalTextureFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: i64,
        arg3: usize,
        arg4: usize,
        arg5: *mut FlutterMetalExternalTexture,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalTexture {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalTexture)."]
    pub struct_size: usize,
    #[doc = " Embedder provided unique identifier to the texture buffer. Given that the\n `texture` handle is passed to the engine to render to, the texture buffer\n is itself owned by the embedder. This `texture_id` is then also given to\n the embedder in the present callback."]
    pub texture_id: i64,
    #[doc = " Handle to the MTLTexture that is owned by the embedder. Engine will render\n the frame into this texture.\n\n A NULL texture is considered invalid."]
    pub texture: FlutterMetalTextureHandle,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalTexture"][::std::mem::size_of::<FlutterMetalTexture>() - 40usize];
    ["Alignment of FlutterMetalTexture"][::std::mem::align_of::<FlutterMetalTexture>() - 8usize];
    ["Offset of field: FlutterMetalTexture::struct_size"]
        [::std::mem::offset_of!(FlutterMetalTexture, struct_size) - 0usize];
    ["Offset of field: FlutterMetalTexture::texture_id"]
        [::std::mem::offset_of!(FlutterMetalTexture, texture_id) - 8usize];
    ["Offset of field: FlutterMetalTexture::texture"]
        [::std::mem::offset_of!(FlutterMetalTexture, texture) - 16usize];
    ["Offset of field: FlutterMetalTexture::user_data"]
        [::std::mem::offset_of!(FlutterMetalTexture, user_data) - 24usize];
    ["Offset of field: FlutterMetalTexture::destruction_callback"]
        [::std::mem::offset_of!(FlutterMetalTexture, destruction_callback) - 32usize];
};
#[doc = " Callback for when a metal texture is requested."]
pub type FlutterMetalTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterFrameInfo,
    ) -> FlutterMetalTexture,
>;
#[doc = " Callback for when a metal texture is presented. The texture_id here\n corresponds to the texture_id provided by the embedder in the\n `FlutterMetalTextureCallback` callback."]
pub type FlutterMetalPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterMetalTexture,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalRendererConfig)."]
    pub struct_size: usize,
    #[doc = " Alias for id<MTLDevice>."]
    pub device: FlutterMetalDeviceHandle,
    #[doc = " Alias for id<MTLCommandQueue>."]
    pub present_command_queue: FlutterMetalCommandQueueHandle,
    #[doc = " The callback that gets invoked when the engine requests the embedder for a\n texture to render to.\n\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub get_next_drawable_callback: FlutterMetalTextureCallback,
    #[doc = " The callback presented to the embedder to present a fully populated metal\n texture to the user.\n\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub present_drawable_callback: FlutterMetalPresentCallback,
    #[doc = " When the embedder specifies that a texture has a frame available, the\n engine will call this method (on an internal engine managed thread) so\n that external texture details can be supplied to the engine for subsequent\n composition."]
    pub external_texture_frame_callback: FlutterMetalTextureFrameCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalRendererConfig"]
        [::std::mem::size_of::<FlutterMetalRendererConfig>() - 48usize];
    ["Alignment of FlutterMetalRendererConfig"]
        [::std::mem::align_of::<FlutterMetalRendererConfig>() - 8usize];
    ["Offset of field: FlutterMetalRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterMetalRendererConfig::device"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, device) - 8usize];
    ["Offset of field: FlutterMetalRendererConfig::present_command_queue"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, present_command_queue) - 16usize];
    ["Offset of field: FlutterMetalRendererConfig::get_next_drawable_callback"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, get_next_drawable_callback) - 24usize];
    ["Offset of field: FlutterMetalRendererConfig::present_drawable_callback"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, present_drawable_callback) - 32usize];
    ["Offset of field: FlutterMetalRendererConfig::external_texture_frame_callback"][::std::mem::offset_of!(
        FlutterMetalRendererConfig,
        external_texture_frame_callback
    ) - 40usize];
};
#[doc = " Alias for VkInstance."]
pub type FlutterVulkanInstanceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkPhysicalDevice."]
pub type FlutterVulkanPhysicalDeviceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkDevice."]
pub type FlutterVulkanDeviceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkQueue."]
pub type FlutterVulkanQueueHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkImage."]
pub type FlutterVulkanImageHandle = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterVulkanImage {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanImage)."]
    pub struct_size: usize,
    #[doc = " Handle to the VkImage that is owned by the embedder. The engine will\n bind this image for writing the frame."]
    pub image: FlutterVulkanImageHandle,
    #[doc = " The VkFormat of the image (for example: VK_FORMAT_R8G8B8A8_UNORM)."]
    pub format: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanImage"][::std::mem::size_of::<FlutterVulkanImage>() - 24usize];
    ["Alignment of FlutterVulkanImage"][::std::mem::align_of::<FlutterVulkanImage>() - 8usize];
    ["Offset of field: FlutterVulkanImage::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanImage, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanImage::image"]
        [::std::mem::offset_of!(FlutterVulkanImage, image) - 8usize];
    ["Offset of field: FlutterVulkanImage::format"]
        [::std::mem::offset_of!(FlutterVulkanImage, format) - 16usize];
};
#[doc = " Callback to fetch a Vulkan function pointer for a given instance. Normally,\n this should return the results of vkGetInstanceProcAddr."]
pub type FlutterVulkanInstanceProcAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: FlutterVulkanInstanceHandle,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback for when a VkImage is requested."]
pub type FlutterVulkanImageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterFrameInfo,
    ) -> FlutterVulkanImage,
>;
#[doc = " Callback for when a VkImage has been written to and is ready for use by the\n embedder."]
pub type FlutterVulkanPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterVulkanImage,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterVulkanRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanRendererConfig)."]
    pub struct_size: usize,
    #[doc = " The Vulkan API version. This should match the value set in\n VkApplicationInfo::apiVersion when the VkInstance was created."]
    pub version: u32,
    #[doc = " VkInstance handle. Must not be destroyed before `FlutterEngineShutdown` is\n called."]
    pub instance: FlutterVulkanInstanceHandle,
    #[doc = " VkPhysicalDevice handle."]
    pub physical_device: FlutterVulkanPhysicalDeviceHandle,
    #[doc = " VkDevice handle. Must not be destroyed before `FlutterEngineShutdown` is\n called."]
    pub device: FlutterVulkanDeviceHandle,
    #[doc = " The queue family index of the VkQueue supplied in the next field."]
    pub queue_family_index: u32,
    #[doc = " VkQueue handle.\n The queue should not be used without protection from a mutex to make sure\n it is not used simultaneously with other threads. That mutex should match\n the one injected via the |get_instance_proc_address_callback|.\n There is a proposal to remove the need for the mutex at\n https://github.com/flutter/flutter/issues/134573."]
    pub queue: FlutterVulkanQueueHandle,
    #[doc = " The number of instance extensions available for enumerating in the next\n field."]
    pub enabled_instance_extension_count: usize,
    #[doc = " Array of enabled instance extension names. This should match the names\n passed to `VkInstanceCreateInfo.ppEnabledExtensionNames` when the instance\n was created, but any subset of enabled instance extensions may be\n specified.\n This field is optional; `nullptr` may be specified.\n This memory is only accessed during the call to FlutterEngineInitialize."]
    pub enabled_instance_extensions: *mut *const ::std::os::raw::c_char,
    #[doc = " The number of device extensions available for enumerating in the next\n field."]
    pub enabled_device_extension_count: usize,
    #[doc = " Array of enabled logical device extension names. This should match the\n names passed to `VkDeviceCreateInfo.ppEnabledExtensionNames` when the\n logical device was created, but any subset of enabled logical device\n extensions may be specified.\n This field is optional; `nullptr` may be specified.\n This memory is only accessed during the call to FlutterEngineInitialize.\n For example: VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"]
    pub enabled_device_extensions: *mut *const ::std::os::raw::c_char,
    #[doc = " The callback invoked when resolving Vulkan function pointers.\n At a bare minimum this should be used to swap out any calls that operate\n on vkQueue's for threadsafe variants that obtain locks for their duration.\n The functions to swap out are \"vkQueueSubmit\" and \"vkQueueWaitIdle\".  An\n example of how to do that can be found in the test\n \"EmbedderTest.CanSwapOutVulkanCalls\" unit-test in\n //shell/platform/embedder/tests/embedder_vk_unittests.cc."]
    pub get_instance_proc_address_callback: FlutterVulkanInstanceProcAddressCallback,
    #[doc = " The callback invoked when the engine requests a VkImage from the embedder\n for rendering the next frame.\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub get_next_image_callback: FlutterVulkanImageCallback,
    #[doc = " The callback invoked when a VkImage has been written to and is ready for\n use by the embedder. Prior to calling this callback, the engine performs\n a host sync, and so the VkImage can be used in a pipeline by the embedder\n without any additional synchronization.\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub present_image_callback: FlutterVulkanPresentCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanRendererConfig"]
        [::std::mem::size_of::<FlutterVulkanRendererConfig>() - 112usize];
    ["Alignment of FlutterVulkanRendererConfig"]
        [::std::mem::align_of::<FlutterVulkanRendererConfig>() - 8usize];
    ["Offset of field: FlutterVulkanRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanRendererConfig::version"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, version) - 8usize];
    ["Offset of field: FlutterVulkanRendererConfig::instance"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, instance) - 16usize];
    ["Offset of field: FlutterVulkanRendererConfig::physical_device"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, physical_device) - 24usize];
    ["Offset of field: FlutterVulkanRendererConfig::device"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, device) - 32usize];
    ["Offset of field: FlutterVulkanRendererConfig::queue_family_index"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, queue_family_index) - 40usize];
    ["Offset of field: FlutterVulkanRendererConfig::queue"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, queue) - 48usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_instance_extension_count"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_instance_extension_count
    ) - 56usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_instance_extensions"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_instance_extensions
    ) - 64usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_device_extension_count"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_device_extension_count
    ) - 72usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_device_extensions"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, enabled_device_extensions) - 80usize];
    ["Offset of field: FlutterVulkanRendererConfig::get_instance_proc_address_callback"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        get_instance_proc_address_callback
    )
        - 88usize];
    ["Offset of field: FlutterVulkanRendererConfig::get_next_image_callback"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, get_next_image_callback) - 96usize];
    ["Offset of field: FlutterVulkanRendererConfig::present_image_callback"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, present_image_callback) - 104usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSoftwareRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterSoftwareRendererConfig)."]
    pub struct_size: usize,
    #[doc = " The callback presented to the embedder to present a fully populated buffer\n to the user. The pixel format of the buffer is the native 32-bit RGBA\n format. The buffer is owned by the Flutter engine and must be copied in\n this callback if needed."]
    pub surface_present_callback: SoftwareSurfacePresentCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareRendererConfig"]
        [::std::mem::size_of::<FlutterSoftwareRendererConfig>() - 16usize];
    ["Alignment of FlutterSoftwareRendererConfig"]
        [::std::mem::align_of::<FlutterSoftwareRendererConfig>() - 8usize];
    ["Offset of field: FlutterSoftwareRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterSoftwareRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterSoftwareRendererConfig::surface_present_callback"]
        [::std::mem::offset_of!(FlutterSoftwareRendererConfig, surface_present_callback) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterRendererConfig {
    pub type_: FlutterRendererType,
    pub __bindgen_anon_1: FlutterRendererConfig__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterRendererConfig__bindgen_ty_1 {
    pub open_gl: FlutterOpenGLRendererConfig,
    pub software: FlutterSoftwareRendererConfig,
    pub metal: FlutterMetalRendererConfig,
    pub vulkan: FlutterVulkanRendererConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRendererConfig__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterRendererConfig__bindgen_ty_1>() - 112usize];
    ["Alignment of FlutterRendererConfig__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterRendererConfig__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::open_gl"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, open_gl) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::software"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, software) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::metal"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, metal) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::vulkan"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, vulkan) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRendererConfig"][::std::mem::size_of::<FlutterRendererConfig>() - 120usize];
    ["Alignment of FlutterRendererConfig"]
        [::std::mem::align_of::<FlutterRendererConfig>() - 8usize];
    ["Offset of field: FlutterRendererConfig::type_"]
        [::std::mem::offset_of!(FlutterRendererConfig, type_) - 0usize];
};
#[doc = " Display refers to a graphics hardware system consisting of a framebuffer,\n typically a monitor or a screen. This ID is unique per display and is\n stable until the Flutter application restarts."]
pub type FlutterEngineDisplayId = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterWindowMetricsEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterWindowMetricsEvent)."]
    pub struct_size: usize,
    #[doc = " Physical width of the window."]
    pub width: usize,
    #[doc = " Physical height of the window."]
    pub height: usize,
    #[doc = " Scale factor for the physical screen."]
    pub pixel_ratio: f64,
    #[doc = " Horizontal physical location of the left side of the window on the screen."]
    pub left: usize,
    #[doc = " Vertical physical location of the top of the window on the screen."]
    pub top: usize,
    #[doc = " Top inset of window."]
    pub physical_view_inset_top: f64,
    #[doc = " Right inset of window."]
    pub physical_view_inset_right: f64,
    #[doc = " Bottom inset of window."]
    pub physical_view_inset_bottom: f64,
    #[doc = " Left inset of window."]
    pub physical_view_inset_left: f64,
    #[doc = " The identifier of the display the view is rendering on."]
    pub display_id: FlutterEngineDisplayId,
    #[doc = " The view that this event is describing."]
    pub view_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterWindowMetricsEvent"]
        [::std::mem::size_of::<FlutterWindowMetricsEvent>() - 96usize];
    ["Alignment of FlutterWindowMetricsEvent"]
        [::std::mem::align_of::<FlutterWindowMetricsEvent>() - 8usize];
    ["Offset of field: FlutterWindowMetricsEvent::struct_size"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, struct_size) - 0usize];
    ["Offset of field: FlutterWindowMetricsEvent::width"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, width) - 8usize];
    ["Offset of field: FlutterWindowMetricsEvent::height"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, height) - 16usize];
    ["Offset of field: FlutterWindowMetricsEvent::pixel_ratio"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, pixel_ratio) - 24usize];
    ["Offset of field: FlutterWindowMetricsEvent::left"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, left) - 32usize];
    ["Offset of field: FlutterWindowMetricsEvent::top"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, top) - 40usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_top"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_top) - 48usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_right"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_right) - 56usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_bottom"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_bottom) - 64usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_left"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_left) - 72usize];
    ["Offset of field: FlutterWindowMetricsEvent::display_id"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, display_id) - 80usize];
    ["Offset of field: FlutterWindowMetricsEvent::view_id"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, view_id) - 88usize];
};
pub const FlutterPointerPhase_kCancel: FlutterPointerPhase = 0;
#[doc = " The pointer, which must have been down (see kDown), is now up.\n\n For touch, this means that the pointer is no longer in contact with the\n screen. For a mouse, it means the last button was released. Note that if\n any other buttons are still pressed when one button is released, that\n should be sent as a kMove rather than a kUp."]
pub const FlutterPointerPhase_kUp: FlutterPointerPhase = 1;
#[doc = " The pointer, which must have been up, is now down.\n\n For touch, this means that the pointer has come into contact with the\n screen. For a mouse, it means a button is now pressed. Note that if any\n other buttons are already pressed when a new button is pressed, that\n should be sent as a kMove rather than a kDown."]
pub const FlutterPointerPhase_kDown: FlutterPointerPhase = 2;
#[doc = " The pointer moved while down.\n\n This is also used for changes in button state that don't cause a kDown or\n kUp, such as releasing one of two pressed buttons."]
pub const FlutterPointerPhase_kMove: FlutterPointerPhase = 3;
#[doc = " The pointer is now sending input to Flutter. For instance, a mouse has\n entered the area where the Flutter content is displayed.\n\n A pointer should always be added before sending any other events."]
pub const FlutterPointerPhase_kAdd: FlutterPointerPhase = 4;
#[doc = " The pointer is no longer sending input to Flutter. For instance, a mouse\n has left the area where the Flutter content is displayed.\n\n A removed pointer should no longer send events until sending a new kAdd."]
pub const FlutterPointerPhase_kRemove: FlutterPointerPhase = 5;
#[doc = " The pointer moved while up."]
pub const FlutterPointerPhase_kHover: FlutterPointerPhase = 6;
#[doc = " A pan/zoom started on this pointer."]
pub const FlutterPointerPhase_kPanZoomStart: FlutterPointerPhase = 7;
#[doc = " The pan/zoom updated."]
pub const FlutterPointerPhase_kPanZoomUpdate: FlutterPointerPhase = 8;
#[doc = " The pan/zoom ended."]
pub const FlutterPointerPhase_kPanZoomEnd: FlutterPointerPhase = 9;
#[doc = " The phase of the pointer event."]
pub type FlutterPointerPhase = ::std::os::raw::c_int;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindMouse: FlutterPointerDeviceKind = 1;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindTouch: FlutterPointerDeviceKind = 2;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindStylus: FlutterPointerDeviceKind = 3;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindTrackpad: FlutterPointerDeviceKind = 4;
#[doc = " The device type that created a pointer event."]
pub type FlutterPointerDeviceKind = ::std::os::raw::c_int;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindNone: FlutterPointerSignalKind = 0;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScroll: FlutterPointerSignalKind = 1;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScrollInertiaCancel:
    FlutterPointerSignalKind = 2;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScale: FlutterPointerSignalKind = 3;
#[doc = " The type of a pointer signal."]
pub type FlutterPointerSignalKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPointerEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterPointerEvent)."]
    pub struct_size: usize,
    pub phase: FlutterPointerPhase,
    #[doc = " The timestamp at which the pointer event was generated. The timestamp\n should be specified in microseconds and the clock should be the same as\n that used by `FlutterEngineGetCurrentTime`."]
    pub timestamp: usize,
    #[doc = " The x coordinate of the pointer event in physical pixels."]
    pub x: f64,
    #[doc = " The y coordinate of the pointer event in physical pixels."]
    pub y: f64,
    #[doc = " An optional device identifier. If this is not specified, it is assumed\n that the embedder has no multi-touch capability."]
    pub device: i32,
    pub signal_kind: FlutterPointerSignalKind,
    #[doc = " The x offset of the scroll in physical pixels."]
    pub scroll_delta_x: f64,
    #[doc = " The y offset of the scroll in physical pixels."]
    pub scroll_delta_y: f64,
    #[doc = " The type of the device generating this event.\n Backwards compatibility note: If this is not set, the device will be\n treated as a mouse, with the primary button set for `kDown` and `kMove`.\n If set explicitly to `kFlutterPointerDeviceKindMouse`, you must set the\n correct buttons."]
    pub device_kind: FlutterPointerDeviceKind,
    #[doc = " The buttons currently pressed, if any."]
    pub buttons: i64,
    #[doc = " The x offset of the pan/zoom in physical pixels."]
    pub pan_x: f64,
    #[doc = " The y offset of the pan/zoom in physical pixels."]
    pub pan_y: f64,
    #[doc = " The scale of the pan/zoom, where 1.0 is the initial scale."]
    pub scale: f64,
    #[doc = " The rotation of the pan/zoom in radians, where 0.0 is the initial angle."]
    pub rotation: f64,
    #[doc = " The identifier of the view that received the pointer event."]
    pub view_id: FlutterViewId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPointerEvent"][::std::mem::size_of::<FlutterPointerEvent>() - 120usize];
    ["Alignment of FlutterPointerEvent"][::std::mem::align_of::<FlutterPointerEvent>() - 8usize];
    ["Offset of field: FlutterPointerEvent::struct_size"]
        [::std::mem::offset_of!(FlutterPointerEvent, struct_size) - 0usize];
    ["Offset of field: FlutterPointerEvent::phase"]
        [::std::mem::offset_of!(FlutterPointerEvent, phase) - 8usize];
    ["Offset of field: FlutterPointerEvent::timestamp"]
        [::std::mem::offset_of!(FlutterPointerEvent, timestamp) - 16usize];
    ["Offset of field: FlutterPointerEvent::x"]
        [::std::mem::offset_of!(FlutterPointerEvent, x) - 24usize];
    ["Offset of field: FlutterPointerEvent::y"]
        [::std::mem::offset_of!(FlutterPointerEvent, y) - 32usize];
    ["Offset of field: FlutterPointerEvent::device"]
        [::std::mem::offset_of!(FlutterPointerEvent, device) - 40usize];
    ["Offset of field: FlutterPointerEvent::signal_kind"]
        [::std::mem::offset_of!(FlutterPointerEvent, signal_kind) - 44usize];
    ["Offset of field: FlutterPointerEvent::scroll_delta_x"]
        [::std::mem::offset_of!(FlutterPointerEvent, scroll_delta_x) - 48usize];
    ["Offset of field: FlutterPointerEvent::scroll_delta_y"]
        [::std::mem::offset_of!(FlutterPointerEvent, scroll_delta_y) - 56usize];
    ["Offset of field: FlutterPointerEvent::device_kind"]
        [::std::mem::offset_of!(FlutterPointerEvent, device_kind) - 64usize];
    ["Offset of field: FlutterPointerEvent::buttons"]
        [::std::mem::offset_of!(FlutterPointerEvent, buttons) - 72usize];
    ["Offset of field: FlutterPointerEvent::pan_x"]
        [::std::mem::offset_of!(FlutterPointerEvent, pan_x) - 80usize];
    ["Offset of field: FlutterPointerEvent::pan_y"]
        [::std::mem::offset_of!(FlutterPointerEvent, pan_y) - 88usize];
    ["Offset of field: FlutterPointerEvent::scale"]
        [::std::mem::offset_of!(FlutterPointerEvent, scale) - 96usize];
    ["Offset of field: FlutterPointerEvent::rotation"]
        [::std::mem::offset_of!(FlutterPointerEvent, rotation) - 104usize];
    ["Offset of field: FlutterPointerEvent::view_id"]
        [::std::mem::offset_of!(FlutterPointerEvent, view_id) - 112usize];
};
pub const FlutterKeyEventType_kFlutterKeyEventTypeUp: FlutterKeyEventType = 1;
pub const FlutterKeyEventType_kFlutterKeyEventTypeDown: FlutterKeyEventType = 2;
pub const FlutterKeyEventType_kFlutterKeyEventTypeRepeat: FlutterKeyEventType = 3;
pub type FlutterKeyEventType = ::std::os::raw::c_int;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeKeyboard: FlutterKeyEventDeviceType =
    1;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeDirectionalPad:
    FlutterKeyEventDeviceType = 2;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeGamepad: FlutterKeyEventDeviceType =
    3;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeJoystick: FlutterKeyEventDeviceType =
    4;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeHdmi: FlutterKeyEventDeviceType = 5;
pub type FlutterKeyEventDeviceType = ::std::os::raw::c_int;
#[doc = " A structure to represent a key event.\n\n Sending `FlutterKeyEvent` via `FlutterEngineSendKeyEvent` results in a\n corresponding `FlutterKeyEvent` to be dispatched in the framework. It is\n embedder's responsibility to ensure the regularity of sent events, since the\n framework only performs simple one-to-one mapping. The events must conform\n the following rules:\n\n  * Each key press sequence shall consist of one key down event (`kind` being\n    `kFlutterKeyEventTypeDown`), zero or more repeat events, and one key up\n    event, representing a physical key button being pressed, held, and\n    released.\n  * All events throughout a key press sequence shall have the same `physical`\n    and `logical`. Having different `character`s is allowed.\n\n A `FlutterKeyEvent` with `physical` 0 and `logical` 0 is an empty event.\n This is the only case either `physical` or `logical` can be 0. An empty\n event must be sent if a key message should be converted to no\n `FlutterKeyEvent`s, for example, when a key down message is received for a\n key that has already been pressed according to the record. This is to ensure\n some `FlutterKeyEvent` arrives at the framework before raw key message.\n See https://github.com/flutter/flutter/issues/87230."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterKeyEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterKeyEvent)."]
    pub struct_size: usize,
    #[doc = " The timestamp at which the key event was generated. The timestamp should\n be specified in microseconds and the clock should be the same as that used\n by `FlutterEngineGetCurrentTime`."]
    pub timestamp: f64,
    #[doc = " The event kind."]
    pub type_: FlutterKeyEventType,
    #[doc = " The USB HID code for the physical key of the event.\n\n For the full definition and list of pre-defined physical keys, see\n `PhysicalKeyboardKey` from the framework.\n\n The only case that `physical` might be 0 is when this is an empty event.\n See `FlutterKeyEvent` for introduction."]
    pub physical: u64,
    #[doc = " The key ID for the logical key of this event.\n\n For the full definition and a list of pre-defined logical keys, see\n `LogicalKeyboardKey` from the framework.\n\n The only case that `logical` might be 0 is when this is an empty event.\n See `FlutterKeyEvent` for introduction."]
    pub logical: u64,
    #[doc = " Null-terminated character input from the event. Can be null. Ignored for\n up events."]
    pub character: *const ::std::os::raw::c_char,
    #[doc = " True if this event does not correspond to a native event.\n\n The embedder is likely to skip events and/or construct new events that do\n not correspond to any native events in order to conform the regularity\n of events (as documented in `FlutterKeyEvent`). An example is when a key\n up is missed due to loss of window focus, on a platform that provides\n query to key pressing status, the embedder might realize that the key has\n been released at the next key event, and should construct a synthesized up\n event immediately before the actual event.\n\n An event being synthesized means that the `timestamp` might greatly\n deviate from the actual time when the event occurs physically."]
    pub synthesized: bool,
    #[doc = " The source device for the key event."]
    pub device_type: FlutterKeyEventDeviceType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterKeyEvent"][::std::mem::size_of::<FlutterKeyEvent>() - 56usize];
    ["Alignment of FlutterKeyEvent"][::std::mem::align_of::<FlutterKeyEvent>() - 8usize];
    ["Offset of field: FlutterKeyEvent::struct_size"]
        [::std::mem::offset_of!(FlutterKeyEvent, struct_size) - 0usize];
    ["Offset of field: FlutterKeyEvent::timestamp"]
        [::std::mem::offset_of!(FlutterKeyEvent, timestamp) - 8usize];
    ["Offset of field: FlutterKeyEvent::type_"]
        [::std::mem::offset_of!(FlutterKeyEvent, type_) - 16usize];
    ["Offset of field: FlutterKeyEvent::physical"]
        [::std::mem::offset_of!(FlutterKeyEvent, physical) - 24usize];
    ["Offset of field: FlutterKeyEvent::logical"]
        [::std::mem::offset_of!(FlutterKeyEvent, logical) - 32usize];
    ["Offset of field: FlutterKeyEvent::character"]
        [::std::mem::offset_of!(FlutterKeyEvent, character) - 40usize];
    ["Offset of field: FlutterKeyEvent::synthesized"]
        [::std::mem::offset_of!(FlutterKeyEvent, synthesized) - 48usize];
    ["Offset of field: FlutterKeyEvent::device_type"]
        [::std::mem::offset_of!(FlutterKeyEvent, device_type) - 52usize];
};
pub type FlutterKeyEventCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterPlatformMessageResponseHandle {
    _unused: [u8; 0],
}
pub type FlutterPlatformMessageResponseHandle = _FlutterPlatformMessageResponseHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPlatformMessage {
    #[doc = " The size of this struct. Must be sizeof(FlutterPlatformMessage)."]
    pub struct_size: usize,
    pub channel: *const ::std::os::raw::c_char,
    pub message: *const u8,
    pub message_size: usize,
    #[doc = " The response handle on which to invoke\n `FlutterEngineSendPlatformMessageResponse` when the response is ready.\n `FlutterEngineSendPlatformMessageResponse` must be called for all messages\n received by the embedder. Failure to call\n `FlutterEngineSendPlatformMessageResponse` will cause a memory leak. It is\n not safe to send multiple responses on a single response object."]
    pub response_handle: *const FlutterPlatformMessageResponseHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformMessage"][::std::mem::size_of::<FlutterPlatformMessage>() - 40usize];
    ["Alignment of FlutterPlatformMessage"]
        [::std::mem::align_of::<FlutterPlatformMessage>() - 8usize];
    ["Offset of field: FlutterPlatformMessage::struct_size"]
        [::std::mem::offset_of!(FlutterPlatformMessage, struct_size) - 0usize];
    ["Offset of field: FlutterPlatformMessage::channel"]
        [::std::mem::offset_of!(FlutterPlatformMessage, channel) - 8usize];
    ["Offset of field: FlutterPlatformMessage::message"]
        [::std::mem::offset_of!(FlutterPlatformMessage, message) - 16usize];
    ["Offset of field: FlutterPlatformMessage::message_size"]
        [::std::mem::offset_of!(FlutterPlatformMessage, message_size) - 24usize];
    ["Offset of field: FlutterPlatformMessage::response_handle"]
        [::std::mem::offset_of!(FlutterPlatformMessage, response_handle) - 32usize];
};
pub type FlutterPlatformMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterPlatformMessage, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterDataCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const u8, arg2: usize, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " The identifier of the platform view. This identifier is specified by the\n application when a platform view is added to the scene via the\n `SceneBuilder.addPlatformView` call."]
pub type FlutterPlatformViewIdentifier = i64;
pub const FlutterStringAttributeType_kSpellOut: FlutterStringAttributeType = 0;
pub const FlutterStringAttributeType_kLocale: FlutterStringAttributeType = 1;
pub type FlutterStringAttributeType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSpellOutStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterSpellOutStringAttribute)."]
    pub struct_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSpellOutStringAttribute"]
        [::std::mem::size_of::<FlutterSpellOutStringAttribute>() - 8usize];
    ["Alignment of FlutterSpellOutStringAttribute"]
        [::std::mem::align_of::<FlutterSpellOutStringAttribute>() - 8usize];
    ["Offset of field: FlutterSpellOutStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterSpellOutStringAttribute, struct_size) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterLocaleStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterLocaleStringAttribute)."]
    pub struct_size: usize,
    pub locale: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLocaleStringAttribute"]
        [::std::mem::size_of::<FlutterLocaleStringAttribute>() - 16usize];
    ["Alignment of FlutterLocaleStringAttribute"]
        [::std::mem::align_of::<FlutterLocaleStringAttribute>() - 8usize];
    ["Offset of field: FlutterLocaleStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterLocaleStringAttribute, struct_size) - 0usize];
    ["Offset of field: FlutterLocaleStringAttribute::locale"]
        [::std::mem::offset_of!(FlutterLocaleStringAttribute, locale) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterStringAttribute)."]
    pub struct_size: usize,
    pub start: usize,
    pub end: usize,
    #[doc = " The type of the attribute described by the subsequent union."]
    pub type_: FlutterStringAttributeType,
    pub __bindgen_anon_1: FlutterStringAttribute__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterStringAttribute__bindgen_ty_1 {
    pub spell_out: *const FlutterSpellOutStringAttribute,
    pub locale: *const FlutterLocaleStringAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterStringAttribute__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterStringAttribute__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterStringAttribute__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterStringAttribute__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterStringAttribute__bindgen_ty_1::spell_out"]
        [::std::mem::offset_of!(FlutterStringAttribute__bindgen_ty_1, spell_out) - 0usize];
    ["Offset of field: FlutterStringAttribute__bindgen_ty_1::locale"]
        [::std::mem::offset_of!(FlutterStringAttribute__bindgen_ty_1, locale) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterStringAttribute"][::std::mem::size_of::<FlutterStringAttribute>() - 40usize];
    ["Alignment of FlutterStringAttribute"]
        [::std::mem::align_of::<FlutterStringAttribute>() - 8usize];
    ["Offset of field: FlutterStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterStringAttribute, struct_size) - 0usize];
    ["Offset of field: FlutterStringAttribute::start"]
        [::std::mem::offset_of!(FlutterStringAttribute, start) - 8usize];
    ["Offset of field: FlutterStringAttribute::end"]
        [::std::mem::offset_of!(FlutterStringAttribute, end) - 16usize];
    ["Offset of field: FlutterStringAttribute::type_"]
        [::std::mem::offset_of!(FlutterStringAttribute, type_) - 24usize];
};
#[doc = " A node that represents some semantic data.\n\n The semantics tree is maintained during the semantics phase of the pipeline\n (i.e., during PipelineOwner.flushSemantics), which happens after\n compositing. Updates are then pushed to embedders via the registered\n `FlutterUpdateSemanticsCallback`.\n\n @deprecated     Use `FlutterSemanticsNode2` instead. In order to preserve\n                 ABI compatibility for existing users, no new fields will be\n                 added to this struct. New fields will continue to be added\n                 to `FlutterSemanticsNode2`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsNode {
    #[doc = " The size of this struct. Must be sizeof(FlutterSemanticsNode)."]
    pub struct_size: usize,
    #[doc = " The unique identifier for this node."]
    pub id: i32,
    #[doc = " The set of semantics flags associated with this node."]
    pub flags: FlutterSemanticsFlag,
    #[doc = " The set of semantics actions applicable to this node."]
    pub actions: FlutterSemanticsAction,
    #[doc = " The position at which the text selection originates."]
    pub text_selection_base: i32,
    #[doc = " The position at which the text selection terminates."]
    pub text_selection_extent: i32,
    #[doc = " The total number of scrollable children that contribute to semantics."]
    pub scroll_child_count: i32,
    #[doc = " The index of the first visible semantic child of a scroll node."]
    pub scroll_index: i32,
    #[doc = " The current scrolling position in logical pixels if the node is\n scrollable."]
    pub scroll_position: f64,
    #[doc = " The maximum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_max: f64,
    #[doc = " The minimum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_min: f64,
    #[doc = " The elevation along the z-axis at which the rect of this semantics node is\n located above its parent."]
    pub elevation: f64,
    #[doc = " Describes how much space the semantics node takes up along the z-axis."]
    pub thickness: f64,
    #[doc = " A textual description of the node."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " A brief description of the result of performing an action on the node."]
    pub hint: *const ::std::os::raw::c_char,
    #[doc = " A textual description of the current value of the node."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionIncrease`\n action has been performed."]
    pub increased_value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionDecrease`\n action has been performed."]
    pub decreased_value: *const ::std::os::raw::c_char,
    #[doc = " The reading direction for `label`, `value`, `hint`, `increasedValue`,\n `decreasedValue`, and `tooltip`."]
    pub text_direction: FlutterTextDirection,
    #[doc = " The bounding box for this node in its coordinate system."]
    pub rect: FlutterRect,
    #[doc = " The transform from this node's coordinate system to its parent's\n coordinate system."]
    pub transform: FlutterTransformation,
    #[doc = " The number of children this node has."]
    pub child_count: usize,
    #[doc = " Array of child node IDs in traversal order. Has length `child_count`."]
    pub children_in_traversal_order: *const i32,
    #[doc = " Array of child node IDs in hit test order. Has length `child_count`."]
    pub children_in_hit_test_order: *const i32,
    #[doc = " The number of custom accessibility action associated with this node."]
    pub custom_accessibility_actions_count: usize,
    #[doc = " Array of `FlutterSemanticsCustomAction` IDs associated with this node.\n Has length `custom_accessibility_actions_count`."]
    pub custom_accessibility_actions: *const i32,
    #[doc = " Identifier of the platform view associated with this semantics node, or\n -1 if none."]
    pub platform_view_id: FlutterPlatformViewIdentifier,
    #[doc = " A textual tooltip attached to the node."]
    pub tooltip: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsNode"][::std::mem::size_of::<FlutterSemanticsNode>() - 288usize];
    ["Alignment of FlutterSemanticsNode"][::std::mem::align_of::<FlutterSemanticsNode>() - 8usize];
    ["Offset of field: FlutterSemanticsNode::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsNode, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsNode::id"]
        [::std::mem::offset_of!(FlutterSemanticsNode, id) - 8usize];
    ["Offset of field: FlutterSemanticsNode::flags"]
        [::std::mem::offset_of!(FlutterSemanticsNode, flags) - 12usize];
    ["Offset of field: FlutterSemanticsNode::actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode, actions) - 16usize];
    ["Offset of field: FlutterSemanticsNode::text_selection_base"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_selection_base) - 20usize];
    ["Offset of field: FlutterSemanticsNode::text_selection_extent"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_selection_extent) - 24usize];
    ["Offset of field: FlutterSemanticsNode::scroll_child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_child_count) - 28usize];
    ["Offset of field: FlutterSemanticsNode::scroll_index"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_index) - 32usize];
    ["Offset of field: FlutterSemanticsNode::scroll_position"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_position) - 40usize];
    ["Offset of field: FlutterSemanticsNode::scroll_extent_max"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_extent_max) - 48usize];
    ["Offset of field: FlutterSemanticsNode::scroll_extent_min"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_extent_min) - 56usize];
    ["Offset of field: FlutterSemanticsNode::elevation"]
        [::std::mem::offset_of!(FlutterSemanticsNode, elevation) - 64usize];
    ["Offset of field: FlutterSemanticsNode::thickness"]
        [::std::mem::offset_of!(FlutterSemanticsNode, thickness) - 72usize];
    ["Offset of field: FlutterSemanticsNode::label"]
        [::std::mem::offset_of!(FlutterSemanticsNode, label) - 80usize];
    ["Offset of field: FlutterSemanticsNode::hint"]
        [::std::mem::offset_of!(FlutterSemanticsNode, hint) - 88usize];
    ["Offset of field: FlutterSemanticsNode::value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, value) - 96usize];
    ["Offset of field: FlutterSemanticsNode::increased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, increased_value) - 104usize];
    ["Offset of field: FlutterSemanticsNode::decreased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, decreased_value) - 112usize];
    ["Offset of field: FlutterSemanticsNode::text_direction"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_direction) - 120usize];
    ["Offset of field: FlutterSemanticsNode::rect"]
        [::std::mem::offset_of!(FlutterSemanticsNode, rect) - 128usize];
    ["Offset of field: FlutterSemanticsNode::transform"]
        [::std::mem::offset_of!(FlutterSemanticsNode, transform) - 160usize];
    ["Offset of field: FlutterSemanticsNode::child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode, child_count) - 232usize];
    ["Offset of field: FlutterSemanticsNode::children_in_traversal_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode, children_in_traversal_order) - 240usize];
    ["Offset of field: FlutterSemanticsNode::children_in_hit_test_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode, children_in_hit_test_order) - 248usize];
    ["Offset of field: FlutterSemanticsNode::custom_accessibility_actions_count"][::std::mem::offset_of!(
        FlutterSemanticsNode,
        custom_accessibility_actions_count
    ) - 256usize];
    ["Offset of field: FlutterSemanticsNode::custom_accessibility_actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode, custom_accessibility_actions) - 264usize];
    ["Offset of field: FlutterSemanticsNode::platform_view_id"]
        [::std::mem::offset_of!(FlutterSemanticsNode, platform_view_id) - 272usize];
    ["Offset of field: FlutterSemanticsNode::tooltip"]
        [::std::mem::offset_of!(FlutterSemanticsNode, tooltip) - 280usize];
};
#[doc = " A node in the Flutter semantics tree.\n\n The semantics tree is maintained during the semantics phase of the pipeline\n (i.e., during PipelineOwner.flushSemantics), which happens after\n compositing. Updates are then pushed to embedders via the registered\n `FlutterUpdateSemanticsCallback2`.\n\n @see https://api.flutter.dev/flutter/semantics/SemanticsNode-class.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsNode2 {
    #[doc = " The size of this struct. Must be sizeof(FlutterSemanticsNode)."]
    pub struct_size: usize,
    #[doc = " The unique identifier for this node."]
    pub id: i32,
    #[doc = " The set of semantics flags associated with this node."]
    pub flags: FlutterSemanticsFlag,
    #[doc = " The set of semantics actions applicable to this node."]
    pub actions: FlutterSemanticsAction,
    #[doc = " The position at which the text selection originates."]
    pub text_selection_base: i32,
    #[doc = " The position at which the text selection terminates."]
    pub text_selection_extent: i32,
    #[doc = " The total number of scrollable children that contribute to semantics."]
    pub scroll_child_count: i32,
    #[doc = " The index of the first visible semantic child of a scroll node."]
    pub scroll_index: i32,
    #[doc = " The current scrolling position in logical pixels if the node is\n scrollable."]
    pub scroll_position: f64,
    #[doc = " The maximum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_max: f64,
    #[doc = " The minimum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_min: f64,
    #[doc = " The elevation along the z-axis at which the rect of this semantics node is\n located above its parent."]
    pub elevation: f64,
    #[doc = " Describes how much space the semantics node takes up along the z-axis."]
    pub thickness: f64,
    #[doc = " A textual description of the node."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " A brief description of the result of performing an action on the node."]
    pub hint: *const ::std::os::raw::c_char,
    #[doc = " A textual description of the current value of the node."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionIncrease`\n action has been performed."]
    pub increased_value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionDecrease`\n action has been performed."]
    pub decreased_value: *const ::std::os::raw::c_char,
    #[doc = " The reading direction for `label`, `value`, `hint`, `increasedValue`,\n `decreasedValue`, and `tooltip`."]
    pub text_direction: FlutterTextDirection,
    #[doc = " The bounding box for this node in its coordinate system."]
    pub rect: FlutterRect,
    #[doc = " The transform from this node's coordinate system to its parent's\n coordinate system."]
    pub transform: FlutterTransformation,
    #[doc = " The number of children this node has."]
    pub child_count: usize,
    #[doc = " Array of child node IDs in traversal order. Has length `child_count`."]
    pub children_in_traversal_order: *const i32,
    #[doc = " Array of child node IDs in hit test order. Has length `child_count`."]
    pub children_in_hit_test_order: *const i32,
    #[doc = " The number of custom accessibility action associated with this node."]
    pub custom_accessibility_actions_count: usize,
    #[doc = " Array of `FlutterSemanticsCustomAction` IDs associated with this node.\n Has length `custom_accessibility_actions_count`."]
    pub custom_accessibility_actions: *const i32,
    #[doc = " Identifier of the platform view associated with this semantics node, or\n -1 if none."]
    pub platform_view_id: FlutterPlatformViewIdentifier,
    #[doc = " A textual tooltip attached to the node."]
    pub tooltip: *const ::std::os::raw::c_char,
    pub label_attribute_count: usize,
    pub label_attributes: *mut *const FlutterStringAttribute,
    pub hint_attribute_count: usize,
    pub hint_attributes: *mut *const FlutterStringAttribute,
    pub value_attribute_count: usize,
    pub value_attributes: *mut *const FlutterStringAttribute,
    pub increased_value_attribute_count: usize,
    pub increased_value_attributes: *mut *const FlutterStringAttribute,
    pub decreased_value_attribute_count: usize,
    pub decreased_value_attributes: *mut *const FlutterStringAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsNode2"][::std::mem::size_of::<FlutterSemanticsNode2>() - 368usize];
    ["Alignment of FlutterSemanticsNode2"]
        [::std::mem::align_of::<FlutterSemanticsNode2>() - 8usize];
    ["Offset of field: FlutterSemanticsNode2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsNode2::id"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, id) - 8usize];
    ["Offset of field: FlutterSemanticsNode2::flags"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, flags) - 12usize];
    ["Offset of field: FlutterSemanticsNode2::actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, actions) - 16usize];
    ["Offset of field: FlutterSemanticsNode2::text_selection_base"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_selection_base) - 20usize];
    ["Offset of field: FlutterSemanticsNode2::text_selection_extent"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_selection_extent) - 24usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_child_count) - 28usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_index"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_index) - 32usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_position"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_position) - 40usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_extent_max"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_extent_max) - 48usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_extent_min"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_extent_min) - 56usize];
    ["Offset of field: FlutterSemanticsNode2::elevation"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, elevation) - 64usize];
    ["Offset of field: FlutterSemanticsNode2::thickness"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, thickness) - 72usize];
    ["Offset of field: FlutterSemanticsNode2::label"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label) - 80usize];
    ["Offset of field: FlutterSemanticsNode2::hint"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint) - 88usize];
    ["Offset of field: FlutterSemanticsNode2::value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value) - 96usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value) - 104usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value) - 112usize];
    ["Offset of field: FlutterSemanticsNode2::text_direction"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_direction) - 120usize];
    ["Offset of field: FlutterSemanticsNode2::rect"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, rect) - 128usize];
    ["Offset of field: FlutterSemanticsNode2::transform"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, transform) - 160usize];
    ["Offset of field: FlutterSemanticsNode2::child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, child_count) - 232usize];
    ["Offset of field: FlutterSemanticsNode2::children_in_traversal_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, children_in_traversal_order) - 240usize];
    ["Offset of field: FlutterSemanticsNode2::children_in_hit_test_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, children_in_hit_test_order) - 248usize];
    ["Offset of field: FlutterSemanticsNode2::custom_accessibility_actions_count"][::std::mem::offset_of!(
        FlutterSemanticsNode2,
        custom_accessibility_actions_count
    ) - 256usize];
    ["Offset of field: FlutterSemanticsNode2::custom_accessibility_actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, custom_accessibility_actions) - 264usize];
    ["Offset of field: FlutterSemanticsNode2::platform_view_id"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, platform_view_id) - 272usize];
    ["Offset of field: FlutterSemanticsNode2::tooltip"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, tooltip) - 280usize];
    ["Offset of field: FlutterSemanticsNode2::label_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label_attribute_count) - 288usize];
    ["Offset of field: FlutterSemanticsNode2::label_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label_attributes) - 296usize];
    ["Offset of field: FlutterSemanticsNode2::hint_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint_attribute_count) - 304usize];
    ["Offset of field: FlutterSemanticsNode2::hint_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint_attributes) - 312usize];
    ["Offset of field: FlutterSemanticsNode2::value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value_attribute_count) - 320usize];
    ["Offset of field: FlutterSemanticsNode2::value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value_attributes) - 328usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value_attribute_count) - 336usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value_attributes) - 344usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value_attribute_count) - 352usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value_attributes) - 360usize];
};
#[doc = " A custom semantics action, or action override.\n\n Custom actions can be registered by applications in order to provide\n semantic actions other than the standard actions available through the\n `FlutterSemanticsAction` enum.\n\n Action overrides are custom actions that the application developer requests\n to be used in place of the standard actions in the `FlutterSemanticsAction`\n enum.\n\n @deprecated     Use `FlutterSemanticsCustomAction2` instead. In order to\n                 preserve ABI compatility for existing users, no new fields\n                 will be added to this struct. New fields will continue to\n                 be added to `FlutterSemanticsCustomAction2`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsCustomAction {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsCustomAction)."]
    pub struct_size: usize,
    #[doc = " The unique custom action or action override ID."]
    pub id: i32,
    #[doc = " For overridden standard actions, corresponds to the\n `FlutterSemanticsAction` to override."]
    pub override_action: FlutterSemanticsAction,
    #[doc = " The user-readable name of this custom semantics action."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " The hint description of this custom semantics action."]
    pub hint: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsCustomAction"]
        [::std::mem::size_of::<FlutterSemanticsCustomAction>() - 32usize];
    ["Alignment of FlutterSemanticsCustomAction"]
        [::std::mem::align_of::<FlutterSemanticsCustomAction>() - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsCustomAction::id"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, id) - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction::override_action"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, override_action) - 12usize];
    ["Offset of field: FlutterSemanticsCustomAction::label"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, label) - 16usize];
    ["Offset of field: FlutterSemanticsCustomAction::hint"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, hint) - 24usize];
};
#[doc = " A custom semantics action, or action override.\n\n Custom actions can be registered by applications in order to provide\n semantic actions other than the standard actions available through the\n `FlutterSemanticsAction` enum.\n\n Action overrides are custom actions that the application developer requests\n to be used in place of the standard actions in the `FlutterSemanticsAction`\n enum.\n\n @see\n https://api.flutter.dev/flutter/semantics/CustomSemanticsAction-class.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsCustomAction2 {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsCustomAction)."]
    pub struct_size: usize,
    #[doc = " The unique custom action or action override ID."]
    pub id: i32,
    #[doc = " For overridden standard actions, corresponds to the\n `FlutterSemanticsAction` to override."]
    pub override_action: FlutterSemanticsAction,
    #[doc = " The user-readable name of this custom semantics action."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " The hint description of this custom semantics action."]
    pub hint: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsCustomAction2"]
        [::std::mem::size_of::<FlutterSemanticsCustomAction2>() - 32usize];
    ["Alignment of FlutterSemanticsCustomAction2"]
        [::std::mem::align_of::<FlutterSemanticsCustomAction2>() - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsCustomAction2::id"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, id) - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction2::override_action"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, override_action) - 12usize];
    ["Offset of field: FlutterSemanticsCustomAction2::label"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, label) - 16usize];
    ["Offset of field: FlutterSemanticsCustomAction2::hint"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, hint) - 24usize];
};
#[doc = " A batch of updates to semantics nodes and custom actions.\n\n @deprecated     Use `FlutterSemanticsUpdate2` instead. Adding members\n                 to `FlutterSemanticsNode` or `FlutterSemanticsCustomAction`\n                 breaks the ABI of this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsUpdate {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsUpdate)."]
    pub struct_size: usize,
    #[doc = " The number of semantics node updates."]
    pub nodes_count: usize,
    pub nodes: *mut FlutterSemanticsNode,
    #[doc = " The number of semantics custom action updates."]
    pub custom_actions_count: usize,
    #[doc = " Array of semantics custom actions. Has length `custom_actions_count`."]
    pub custom_actions: *mut FlutterSemanticsCustomAction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsUpdate"][::std::mem::size_of::<FlutterSemanticsUpdate>() - 40usize];
    ["Alignment of FlutterSemanticsUpdate"]
        [::std::mem::align_of::<FlutterSemanticsUpdate>() - 8usize];
    ["Offset of field: FlutterSemanticsUpdate::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsUpdate::nodes_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, nodes_count) - 8usize];
    ["Offset of field: FlutterSemanticsUpdate::nodes"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, nodes) - 16usize];
    ["Offset of field: FlutterSemanticsUpdate::custom_actions_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, custom_actions_count) - 24usize];
    ["Offset of field: FlutterSemanticsUpdate::custom_actions"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, custom_actions) - 32usize];
};
#[doc = " A batch of updates to semantics nodes and custom actions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsUpdate2 {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsUpdate2)."]
    pub struct_size: usize,
    #[doc = " The number of semantics node updates."]
    pub node_count: usize,
    pub nodes: *mut *mut FlutterSemanticsNode2,
    #[doc = " The number of semantics custom action updates."]
    pub custom_action_count: usize,
    #[doc = " Array of semantics custom action pointers. Has length\n `custom_action_count`."]
    pub custom_actions: *mut *mut FlutterSemanticsCustomAction2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsUpdate2"][::std::mem::size_of::<FlutterSemanticsUpdate2>() - 40usize];
    ["Alignment of FlutterSemanticsUpdate2"]
        [::std::mem::align_of::<FlutterSemanticsUpdate2>() - 8usize];
    ["Offset of field: FlutterSemanticsUpdate2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsUpdate2::node_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, node_count) - 8usize];
    ["Offset of field: FlutterSemanticsUpdate2::nodes"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, nodes) - 16usize];
    ["Offset of field: FlutterSemanticsUpdate2::custom_action_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, custom_action_count) - 24usize];
    ["Offset of field: FlutterSemanticsUpdate2::custom_actions"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, custom_actions) - 32usize];
};
pub type FlutterUpdateSemanticsNodeCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsNode, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterUpdateSemanticsCustomActionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const FlutterSemanticsCustomAction,
        arg2: *mut ::std::os::raw::c_void,
    ),
>;
pub type FlutterUpdateSemanticsCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsUpdate, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterUpdateSemanticsCallback2 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsUpdate2, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " An update to whether a message channel has a listener set or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterChannelUpdate {
    #[doc = " The size of the struct. Must be sizeof(FlutterChannelUpdate)."]
    pub struct_size: usize,
    #[doc = " The name of the channel."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " True if a listener has been set, false if one has been cleared."]
    pub listening: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterChannelUpdate"][::std::mem::size_of::<FlutterChannelUpdate>() - 24usize];
    ["Alignment of FlutterChannelUpdate"][::std::mem::align_of::<FlutterChannelUpdate>() - 8usize];
    ["Offset of field: FlutterChannelUpdate::struct_size"]
        [::std::mem::offset_of!(FlutterChannelUpdate, struct_size) - 0usize];
    ["Offset of field: FlutterChannelUpdate::channel"]
        [::std::mem::offset_of!(FlutterChannelUpdate, channel) - 8usize];
    ["Offset of field: FlutterChannelUpdate::listening"]
        [::std::mem::offset_of!(FlutterChannelUpdate, listening) - 16usize];
};
pub type FlutterChannelUpdateCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterChannelUpdate, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterTaskRunner {
    _unused: [u8; 0],
}
pub type FlutterTaskRunner = *mut _FlutterTaskRunner;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterTask {
    pub runner: FlutterTaskRunner,
    pub task: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTask"][::std::mem::size_of::<FlutterTask>() - 16usize];
    ["Alignment of FlutterTask"][::std::mem::align_of::<FlutterTask>() - 8usize];
    ["Offset of field: FlutterTask::runner"][::std::mem::offset_of!(FlutterTask, runner) - 0usize];
    ["Offset of field: FlutterTask::task"][::std::mem::offset_of!(FlutterTask, task) - 8usize];
};
pub type FlutterTaskRunnerPostTaskCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: FlutterTask, arg2: u64, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " An interface used by the Flutter engine to execute tasks at the target time\n on a specified thread. There should be a 1-1 relationship between a thread\n and a task runner. It is undefined behavior to run a task on a thread that\n is not associated with its task runner."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterTaskRunnerDescription {
    #[doc = " The size of this struct. Must be sizeof(FlutterTaskRunnerDescription)."]
    pub struct_size: usize,
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " May be called from any thread. Should return true if tasks posted on the\n calling thread will be run on that same thread.\n\n @attention     This field is required."]
    pub runs_task_on_current_thread_callback: BoolCallback,
    #[doc = " May be called from any thread. The given task should be executed by the\n embedder on the thread associated with that task runner by calling\n `FlutterEngineRunTask` at the given target time. The system monotonic\n clock should be used for the target time. The target time is the absolute\n time from epoch (NOT a delta) at which the task must be returned back to\n the engine on the correct thread. If the embedder needs to calculate a\n delta, `FlutterEngineGetCurrentTime` may be called and the difference used\n as the delta.\n\n @attention     This field is required."]
    pub post_task_callback: FlutterTaskRunnerPostTaskCallback,
    #[doc = " A unique identifier for the task runner. If multiple task runners service\n tasks on the same thread, their identifiers must match."]
    pub identifier: usize,
    #[doc = " The callback invoked when the task runner is destroyed."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTaskRunnerDescription"]
        [::std::mem::size_of::<FlutterTaskRunnerDescription>() - 48usize];
    ["Alignment of FlutterTaskRunnerDescription"]
        [::std::mem::align_of::<FlutterTaskRunnerDescription>() - 8usize];
    ["Offset of field: FlutterTaskRunnerDescription::struct_size"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, struct_size) - 0usize];
    ["Offset of field: FlutterTaskRunnerDescription::user_data"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, user_data) - 8usize];
    ["Offset of field: FlutterTaskRunnerDescription::runs_task_on_current_thread_callback"][::std::mem::offset_of!(
        FlutterTaskRunnerDescription,
        runs_task_on_current_thread_callback
    )
        - 16usize];
    ["Offset of field: FlutterTaskRunnerDescription::post_task_callback"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, post_task_callback) - 24usize];
    ["Offset of field: FlutterTaskRunnerDescription::identifier"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, identifier) - 32usize];
    ["Offset of field: FlutterTaskRunnerDescription::destruction_callback"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, destruction_callback) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterCustomTaskRunners {
    #[doc = " The size of this struct. Must be sizeof(FlutterCustomTaskRunners)."]
    pub struct_size: usize,
    #[doc = " Specify the task runner for the thread on which the `FlutterEngineRun`\n call is made. The same task runner description can be specified for both\n the render and platform task runners. This makes the Flutter engine use\n the same thread for both task runners."]
    pub platform_task_runner: *const FlutterTaskRunnerDescription,
    #[doc = " Specify the task runner for the thread on which the render tasks will be\n run. The same task runner description can be specified for both the render\n and platform task runners. This makes the Flutter engine use the same\n thread for both task runners."]
    pub render_task_runner: *const FlutterTaskRunnerDescription,
    #[doc = " Specify a callback that is used to set the thread priority for embedder\n task runners."]
    pub thread_priority_setter:
        ::std::option::Option<unsafe extern "C" fn(arg1: FlutterThreadPriority)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterCustomTaskRunners"]
        [::std::mem::size_of::<FlutterCustomTaskRunners>() - 32usize];
    ["Alignment of FlutterCustomTaskRunners"]
        [::std::mem::align_of::<FlutterCustomTaskRunners>() - 8usize];
    ["Offset of field: FlutterCustomTaskRunners::struct_size"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, struct_size) - 0usize];
    ["Offset of field: FlutterCustomTaskRunners::platform_task_runner"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, platform_task_runner) - 8usize];
    ["Offset of field: FlutterCustomTaskRunners::render_task_runner"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, render_task_runner) - 16usize];
    ["Offset of field: FlutterCustomTaskRunners::thread_priority_setter"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, thread_priority_setter) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterOpenGLBackingStore {
    #[doc = " The type of the OpenGL backing store. Currently, it can either be a\n texture or a framebuffer."]
    pub type_: FlutterOpenGLTargetType,
    pub __bindgen_anon_1: FlutterOpenGLBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterOpenGLBackingStore__bindgen_ty_1 {
    #[doc = " A texture for Flutter to render into."]
    pub texture: FlutterOpenGLTexture,
    #[doc = " A framebuffer for Flutter to render into. The embedder must ensure that\n the framebuffer is complete."]
    pub framebuffer: FlutterOpenGLFramebuffer,
    #[doc = " A surface for Flutter to render into. Basically a wrapper around\n a closure that'll be called when the surface should be made current."]
    pub surface: FlutterOpenGLSurface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterOpenGLBackingStore__bindgen_ty_1>() - 48usize];
    ["Alignment of FlutterOpenGLBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterOpenGLBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::texture"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, texture) - 0usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::framebuffer"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, framebuffer) - 0usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::surface"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, surface) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLBackingStore"]
        [::std::mem::size_of::<FlutterOpenGLBackingStore>() - 56usize];
    ["Alignment of FlutterOpenGLBackingStore"]
        [::std::mem::align_of::<FlutterOpenGLBackingStore>() - 8usize];
    ["Offset of field: FlutterOpenGLBackingStore::type_"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSoftwareBackingStore {
    #[doc = " A pointer to the raw bytes of the allocation described by this software\n backing store."]
    pub allocation: *const ::std::os::raw::c_void,
    #[doc = " The number of bytes in a single row of the allocation."]
    pub row_bytes: usize,
    #[doc = " The number of rows in the allocation."]
    pub height: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareBackingStore"]
        [::std::mem::size_of::<FlutterSoftwareBackingStore>() - 40usize];
    ["Alignment of FlutterSoftwareBackingStore"]
        [::std::mem::align_of::<FlutterSoftwareBackingStore>() - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore::allocation"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, allocation) - 0usize];
    ["Offset of field: FlutterSoftwareBackingStore::row_bytes"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, row_bytes) - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore::height"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, height) - 16usize];
    ["Offset of field: FlutterSoftwareBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, user_data) - 24usize];
    ["Offset of field: FlutterSoftwareBackingStore::destruction_callback"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, destruction_callback) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSoftwareBackingStore2 {
    #[doc = " The size of this struct. Must be sizeof(FlutterSoftwareBackingStore2)."]
    pub struct_size: usize,
    #[doc = " A pointer to the raw bytes of the allocation described by this software\n backing store."]
    pub allocation: *const ::std::os::raw::c_void,
    #[doc = " The number of bytes in a single row of the allocation."]
    pub row_bytes: usize,
    #[doc = " The number of rows in the allocation."]
    pub height: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
    #[doc = " The pixel format that the engine should use to render into the allocation.\n\n On Linux, kFlutterSoftwarePixelFormatBGRA8888 is most commonly used."]
    pub pixel_format: FlutterSoftwarePixelFormat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareBackingStore2"]
        [::std::mem::size_of::<FlutterSoftwareBackingStore2>() - 56usize];
    ["Alignment of FlutterSoftwareBackingStore2"]
        [::std::mem::align_of::<FlutterSoftwareBackingStore2>() - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore2::struct_size"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, struct_size) - 0usize];
    ["Offset of field: FlutterSoftwareBackingStore2::allocation"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, allocation) - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore2::row_bytes"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, row_bytes) - 16usize];
    ["Offset of field: FlutterSoftwareBackingStore2::height"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, height) - 24usize];
    ["Offset of field: FlutterSoftwareBackingStore2::user_data"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, user_data) - 32usize];
    ["Offset of field: FlutterSoftwareBackingStore2::destruction_callback"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, destruction_callback) - 40usize];
    ["Offset of field: FlutterSoftwareBackingStore2::pixel_format"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, pixel_format) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterMetalBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalBackingStore)."]
    pub struct_size: usize,
    pub __bindgen_anon_1: FlutterMetalBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterMetalBackingStore__bindgen_ty_1 {
    pub texture: FlutterMetalTexture,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterMetalBackingStore__bindgen_ty_1>() - 40usize];
    ["Alignment of FlutterMetalBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterMetalBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterMetalBackingStore__bindgen_ty_1::texture"]
        [::std::mem::offset_of!(FlutterMetalBackingStore__bindgen_ty_1, texture) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalBackingStore"]
        [::std::mem::size_of::<FlutterMetalBackingStore>() - 48usize];
    ["Alignment of FlutterMetalBackingStore"]
        [::std::mem::align_of::<FlutterMetalBackingStore>() - 8usize];
    ["Offset of field: FlutterMetalBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterMetalBackingStore, struct_size) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterVulkanBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanBackingStore)."]
    pub struct_size: usize,
    #[doc = " The image that the layer will be rendered to. This image must already be\n available for the engine to bind for writing when it's given to the engine\n via the backing store creation callback. The engine will perform a host\n sync for all layers prior to calling the compositor present callback, and\n so the written layer images can be freely bound by the embedder without\n any additional synchronization."]
    pub image: *const FlutterVulkanImage,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanBackingStore"]
        [::std::mem::size_of::<FlutterVulkanBackingStore>() - 32usize];
    ["Alignment of FlutterVulkanBackingStore"]
        [::std::mem::align_of::<FlutterVulkanBackingStore>() - 8usize];
    ["Offset of field: FlutterVulkanBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanBackingStore::image"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, image) - 8usize];
    ["Offset of field: FlutterVulkanBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, user_data) - 16usize];
    ["Offset of field: FlutterVulkanBackingStore::destruction_callback"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, destruction_callback) - 24usize];
};
#[doc = " Indicates that the Flutter application requested that an opacity be\n applied to the platform view."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeOpacity:
    FlutterPlatformViewMutationType = 0;
#[doc = " Indicates that the Flutter application requested that the platform view be\n clipped using a rectangle."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeClipRect:
    FlutterPlatformViewMutationType = 1;
#[doc = " Indicates that the Flutter application requested that the platform view be\n clipped using a rounded rectangle."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeClipRoundedRect:
    FlutterPlatformViewMutationType = 2;
#[doc = " Indicates that the Flutter application requested that the platform view be\n transformed before composition."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeTransformation:
    FlutterPlatformViewMutationType = 3;
pub type FlutterPlatformViewMutationType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterPlatformViewMutation {
    #[doc = " The type of the mutation described by the subsequent union."]
    pub type_: FlutterPlatformViewMutationType,
    pub __bindgen_anon_1: FlutterPlatformViewMutation__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterPlatformViewMutation__bindgen_ty_1 {
    pub opacity: f64,
    pub clip_rect: FlutterRect,
    pub clip_rounded_rect: FlutterRoundedRect,
    pub transformation: FlutterTransformation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformViewMutation__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterPlatformViewMutation__bindgen_ty_1>() - 96usize];
    ["Alignment of FlutterPlatformViewMutation__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterPlatformViewMutation__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::opacity"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation__bindgen_ty_1, opacity) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::clip_rect"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation__bindgen_ty_1, clip_rect) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::clip_rounded_rect"][::std::mem::offset_of!(
        FlutterPlatformViewMutation__bindgen_ty_1,
        clip_rounded_rect
    ) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::transformation"][::std::mem::offset_of!(
        FlutterPlatformViewMutation__bindgen_ty_1,
        transformation
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformViewMutation"]
        [::std::mem::size_of::<FlutterPlatformViewMutation>() - 104usize];
    ["Alignment of FlutterPlatformViewMutation"]
        [::std::mem::align_of::<FlutterPlatformViewMutation>() - 8usize];
    ["Offset of field: FlutterPlatformViewMutation::type_"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation, type_) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPlatformView {
    #[doc = " The size of this struct. Must be sizeof(FlutterPlatformView)."]
    pub struct_size: usize,
    #[doc = " The identifier of this platform view. This identifier is specified by the\n application when a platform view is added to the scene via the\n `SceneBuilder.addPlatformView` call."]
    pub identifier: FlutterPlatformViewIdentifier,
    #[doc = " The number of mutations to be applied to the platform view by the embedder\n before on-screen composition."]
    pub mutations_count: usize,
    #[doc = " The mutations to be applied by this platform view before it is composited\n on-screen. The Flutter application may transform the platform view but\n these transformations cannot be affected by the Flutter compositor because\n it does not render platform views. Since the embedder is responsible for\n composition of these views, it is also the embedder's responsibility to\n affect the appropriate transformation.\n\n The mutations must be applied in order. The mutations done in the\n collection don't take into account the device pixel ratio or the root\n surface transformation. If these exist, the first mutation in the list\n will be a transformation mutation to make sure subsequent mutations are in\n the correct coordinate space."]
    pub mutations: *mut *const FlutterPlatformViewMutation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformView"][::std::mem::size_of::<FlutterPlatformView>() - 32usize];
    ["Alignment of FlutterPlatformView"][::std::mem::align_of::<FlutterPlatformView>() - 8usize];
    ["Offset of field: FlutterPlatformView::struct_size"]
        [::std::mem::offset_of!(FlutterPlatformView, struct_size) - 0usize];
    ["Offset of field: FlutterPlatformView::identifier"]
        [::std::mem::offset_of!(FlutterPlatformView, identifier) - 8usize];
    ["Offset of field: FlutterPlatformView::mutations_count"]
        [::std::mem::offset_of!(FlutterPlatformView, mutations_count) - 16usize];
    ["Offset of field: FlutterPlatformView::mutations"]
        [::std::mem::offset_of!(FlutterPlatformView, mutations) - 24usize];
};
#[doc = " Specifies an OpenGL backing store. Can either be an OpenGL texture or\n framebuffer."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeOpenGL: FlutterBackingStoreType = 0;
#[doc = " Specified an software allocation for Flutter to render into using the CPU."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeSoftware: FlutterBackingStoreType = 1;
#[doc = " Specifies a Metal backing store. This is backed by a Metal texture."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeMetal: FlutterBackingStoreType = 2;
#[doc = " Specifies a Vulkan backing store. This is backed by a Vulkan VkImage."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeVulkan: FlutterBackingStoreType = 3;
#[doc = " Specifies a allocation that the engine should render into using\n software rendering."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeSoftware2: FlutterBackingStoreType = 4;
pub type FlutterBackingStoreType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStore)."]
    pub struct_size: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. The embedder may\n use this to associate resources that are tied to the lifecycle of the\n `FlutterBackingStore`."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Specifies the type of backing store."]
    pub type_: FlutterBackingStoreType,
    #[doc = " Indicates if this backing store was updated since the last time it was\n associated with a presented layer."]
    pub did_update: bool,
    pub __bindgen_anon_1: FlutterBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterBackingStore__bindgen_ty_1 {
    #[doc = " The description of the OpenGL backing store."]
    pub open_gl: FlutterOpenGLBackingStore,
    #[doc = " The description of the software backing store."]
    pub software: FlutterSoftwareBackingStore,
    #[doc = " The description of the software backing store."]
    pub software2: FlutterSoftwareBackingStore2,
    pub metal: FlutterMetalBackingStore,
    pub vulkan: FlutterVulkanBackingStore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterBackingStore__bindgen_ty_1>() - 56usize];
    ["Alignment of FlutterBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::open_gl"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, open_gl) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::software"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, software) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::software2"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, software2) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::metal"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, metal) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::vulkan"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, vulkan) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStore"][::std::mem::size_of::<FlutterBackingStore>() - 80usize];
    ["Alignment of FlutterBackingStore"][::std::mem::align_of::<FlutterBackingStore>() - 8usize];
    ["Offset of field: FlutterBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStore, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterBackingStore, user_data) - 8usize];
    ["Offset of field: FlutterBackingStore::type_"]
        [::std::mem::offset_of!(FlutterBackingStore, type_) - 16usize];
    ["Offset of field: FlutterBackingStore::did_update"]
        [::std::mem::offset_of!(FlutterBackingStore, did_update) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterBackingStoreConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStoreConfig)."]
    pub struct_size: usize,
    #[doc = " The size of the render target the engine expects to render into."]
    pub size: FlutterSize,
    #[doc = " The identifier for the view that the engine will use this backing store to\n render into."]
    pub view_id: FlutterViewId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStoreConfig"]
        [::std::mem::size_of::<FlutterBackingStoreConfig>() - 32usize];
    ["Alignment of FlutterBackingStoreConfig"]
        [::std::mem::align_of::<FlutterBackingStoreConfig>() - 8usize];
    ["Offset of field: FlutterBackingStoreConfig::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStoreConfig::size"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, size) - 8usize];
    ["Offset of field: FlutterBackingStoreConfig::view_id"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, view_id) - 24usize];
};
#[doc = " Indicates that the contents of this layer are rendered by Flutter into a\n backing store."]
pub const FlutterLayerContentType_kFlutterLayerContentTypeBackingStore: FlutterLayerContentType = 0;
#[doc = " Indicates that the contents of this layer are determined by the embedder."]
pub const FlutterLayerContentType_kFlutterLayerContentTypePlatformView: FlutterLayerContentType = 1;
pub type FlutterLayerContentType = ::std::os::raw::c_int;
#[doc = " A region represented by a collection of non-overlapping rectangles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRegion {
    #[doc = " The size of this struct. Must be sizeof(FlutterRegion)."]
    pub struct_size: usize,
    #[doc = " Number of rectangles in the region."]
    pub rects_count: usize,
    #[doc = " The rectangles that make up the region."]
    pub rects: *mut FlutterRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRegion"][::std::mem::size_of::<FlutterRegion>() - 24usize];
    ["Alignment of FlutterRegion"][::std::mem::align_of::<FlutterRegion>() - 8usize];
    ["Offset of field: FlutterRegion::struct_size"]
        [::std::mem::offset_of!(FlutterRegion, struct_size) - 0usize];
    ["Offset of field: FlutterRegion::rects_count"]
        [::std::mem::offset_of!(FlutterRegion, rects_count) - 8usize];
    ["Offset of field: FlutterRegion::rects"]
        [::std::mem::offset_of!(FlutterRegion, rects) - 16usize];
};
#[doc = " Contains additional information about the backing store provided\n during presentation to the embedder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterBackingStorePresentInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStorePresentInfo)."]
    pub struct_size: usize,
    #[doc = " The area of the backing store that contains Flutter contents. Pixels\n outside of this area are transparent and the embedder may choose not\n to render them. Coordinates are in physical pixels."]
    pub paint_region: *mut FlutterRegion,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStorePresentInfo"]
        [::std::mem::size_of::<FlutterBackingStorePresentInfo>() - 16usize];
    ["Alignment of FlutterBackingStorePresentInfo"]
        [::std::mem::align_of::<FlutterBackingStorePresentInfo>() - 8usize];
    ["Offset of field: FlutterBackingStorePresentInfo::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStorePresentInfo, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStorePresentInfo::paint_region"]
        [::std::mem::offset_of!(FlutterBackingStorePresentInfo, paint_region) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterLayer {
    #[doc = " This size of this struct. Must be sizeof(FlutterLayer)."]
    pub struct_size: usize,
    #[doc = " Each layer displays contents in one way or another. The type indicates\n whether those contents are specified by Flutter or the embedder."]
    pub type_: FlutterLayerContentType,
    pub __bindgen_anon_1: FlutterLayer__bindgen_ty_1,
    #[doc = " The offset of this layer (in physical pixels) relative to the top left of\n the root surface used by the engine."]
    pub offset: FlutterPoint,
    #[doc = " The size of the layer (in physical pixels)."]
    pub size: FlutterSize,
    #[doc = " Extra information for the backing store that the embedder may\n use during presentation."]
    pub backing_store_present_info: *mut FlutterBackingStorePresentInfo,
    pub presentation_time: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterLayer__bindgen_ty_1 {
    #[doc = " Indicates that the contents of this layer are rendered by Flutter into a\n backing store."]
    pub backing_store: *const FlutterBackingStore,
    #[doc = " Indicates that the contents of this layer are determined by the\n embedder."]
    pub platform_view: *const FlutterPlatformView,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLayer__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterLayer__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterLayer__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterLayer__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterLayer__bindgen_ty_1::backing_store"]
        [::std::mem::offset_of!(FlutterLayer__bindgen_ty_1, backing_store) - 0usize];
    ["Offset of field: FlutterLayer__bindgen_ty_1::platform_view"]
        [::std::mem::offset_of!(FlutterLayer__bindgen_ty_1, platform_view) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLayer"][::std::mem::size_of::<FlutterLayer>() - 72usize];
    ["Alignment of FlutterLayer"][::std::mem::align_of::<FlutterLayer>() - 8usize];
    ["Offset of field: FlutterLayer::struct_size"]
        [::std::mem::offset_of!(FlutterLayer, struct_size) - 0usize];
    ["Offset of field: FlutterLayer::type_"][::std::mem::offset_of!(FlutterLayer, type_) - 8usize];
    ["Offset of field: FlutterLayer::offset"]
        [::std::mem::offset_of!(FlutterLayer, offset) - 24usize];
    ["Offset of field: FlutterLayer::size"][::std::mem::offset_of!(FlutterLayer, size) - 40usize];
    ["Offset of field: FlutterLayer::backing_store_present_info"]
        [::std::mem::offset_of!(FlutterLayer, backing_store_present_info) - 56usize];
    ["Offset of field: FlutterLayer::presentation_time"]
        [::std::mem::offset_of!(FlutterLayer, presentation_time) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPresentViewInfo {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterPresentViewInfo)."]
    pub struct_size: usize,
    #[doc = " The identifier of the target view."]
    pub view_id: FlutterViewId,
    #[doc = " The layers that should be composited onto the view."]
    pub layers: *mut *const FlutterLayer,
    #[doc = " The count of layers."]
    pub layers_count: usize,
    #[doc = " The |FlutterCompositor.user_data|."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPresentViewInfo"][::std::mem::size_of::<FlutterPresentViewInfo>() - 40usize];
    ["Alignment of FlutterPresentViewInfo"]
        [::std::mem::align_of::<FlutterPresentViewInfo>() - 8usize];
    ["Offset of field: FlutterPresentViewInfo::struct_size"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, struct_size) - 0usize];
    ["Offset of field: FlutterPresentViewInfo::view_id"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, view_id) - 8usize];
    ["Offset of field: FlutterPresentViewInfo::layers"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, layers) - 16usize];
    ["Offset of field: FlutterPresentViewInfo::layers_count"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, layers_count) - 24usize];
    ["Offset of field: FlutterPresentViewInfo::user_data"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, user_data) - 32usize];
};
pub type FlutterBackingStoreCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        config: *const FlutterBackingStoreConfig,
        backing_store_out: *mut FlutterBackingStore,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type FlutterBackingStoreCollectCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *const FlutterBackingStore,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type FlutterLayersPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        layers: *mut *const FlutterLayer,
        layers_count: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " The callback invoked when the embedder should present to a view.\n\n The |FlutterPresentViewInfo| will be deallocated once the callback returns."]
pub type FlutterPresentViewCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FlutterPresentViewInfo) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterCompositor {
    #[doc = " This size of this struct. Must be sizeof(FlutterCompositor)."]
    pub struct_size: usize,
    #[doc = " A baton that in not interpreted by the engine in any way. If it passed\n back to the embedder in `FlutterCompositor.create_backing_store_callback`,\n `FlutterCompositor.collect_backing_store_callback`,\n `FlutterCompositor.present_layers_callback`, and\n `FlutterCompositor.present_view_callback`."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " A callback invoked by the engine to obtain a backing store for a specific\n `FlutterLayer`.\n\n On ABI stability: Callers must take care to restrict access within\n `FlutterBackingStore::struct_size` when specifying a new backing store to\n the engine. This only matters if the embedder expects to be used with\n engines older than the version whose headers it used during compilation.\n\n The callback should return true if the operation was successful."]
    pub create_backing_store_callback: FlutterBackingStoreCreateCallback,
    #[doc = " A callback invoked by the engine to release the backing store. The\n embedder may collect any resources associated with the backing store.\n\n The callback should return true if the operation was successful."]
    pub collect_backing_store_callback: FlutterBackingStoreCollectCallback,
    #[doc = " Callback invoked by the engine to composite the contents of each layer\n onto the implicit view.\n\n DEPRECATED: Use `present_view_callback` to support multiple views.\n If this callback is provided, `FlutterEngineAddView` and\n `FlutterEngineRemoveView` should not be used.\n\n Only one of `present_layers_callback` and `present_view_callback` may be\n provided. Providing both is an error and engine initialization will\n terminate.\n\n The callback should return true if the operation was successful."]
    pub present_layers_callback: FlutterLayersPresentCallback,
    #[doc = " Avoid caching backing stores provided by this compositor.\n\n The engine has an internal backing store cache. Instead of\n creating & destroying backing stores for every frame, created\n backing stores are automatically reused for subsequent frames.\n\n If you wish to change this behavior and destroy backing stores after\n they've been used once, and create new backing stores for every frame,\n you can set this bool to true."]
    pub avoid_backing_store_cache: bool,
    #[doc = " Callback invoked by the engine to composite the contents of each layer\n onto the specified view.\n\n Only one of `present_layers_callback` and `present_view_callback` may be\n provided. Providing both is an error and engine initialization will\n terminate.\n\n The callback should return true if the operation was successful."]
    pub present_view_callback: FlutterPresentViewCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterCompositor"][::std::mem::size_of::<FlutterCompositor>() - 56usize];
    ["Alignment of FlutterCompositor"][::std::mem::align_of::<FlutterCompositor>() - 8usize];
    ["Offset of field: FlutterCompositor::struct_size"]
        [::std::mem::offset_of!(FlutterCompositor, struct_size) - 0usize];
    ["Offset of field: FlutterCompositor::user_data"]
        [::std::mem::offset_of!(FlutterCompositor, user_data) - 8usize];
    ["Offset of field: FlutterCompositor::create_backing_store_callback"]
        [::std::mem::offset_of!(FlutterCompositor, create_backing_store_callback) - 16usize];
    ["Offset of field: FlutterCompositor::collect_backing_store_callback"]
        [::std::mem::offset_of!(FlutterCompositor, collect_backing_store_callback) - 24usize];
    ["Offset of field: FlutterCompositor::present_layers_callback"]
        [::std::mem::offset_of!(FlutterCompositor, present_layers_callback) - 32usize];
    ["Offset of field: FlutterCompositor::avoid_backing_store_cache"]
        [::std::mem::offset_of!(FlutterCompositor, avoid_backing_store_cache) - 40usize];
    ["Offset of field: FlutterCompositor::present_view_callback"]
        [::std::mem::offset_of!(FlutterCompositor, present_view_callback) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterLocale {
    #[doc = " This size of this struct. Must be sizeof(FlutterLocale)."]
    pub struct_size: usize,
    #[doc = " The language code of the locale. For example, \"en\". This is a required\n field. The string must be null terminated. It may be collected after the\n call to `FlutterEngineUpdateLocales`."]
    pub language_code: *const ::std::os::raw::c_char,
    #[doc = " The country code of the locale. For example, \"US\". This is a an optional\n field. The string must be null terminated if present. It may be collected\n after the call to `FlutterEngineUpdateLocales`. If not present, a\n `nullptr` may be specified."]
    pub country_code: *const ::std::os::raw::c_char,
    #[doc = " The script code of the locale. This is a an optional field. The string\n must be null terminated if present. It may be collected after the call to\n `FlutterEngineUpdateLocales`. If not present, a `nullptr` may be\n specified."]
    pub script_code: *const ::std::os::raw::c_char,
    #[doc = " The variant code of the locale. This is a an optional field. The string\n must be null terminated if present. It may be collected after the call to\n `FlutterEngineUpdateLocales`. If not present, a `nullptr` may be\n specified."]
    pub variant_code: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLocale"][::std::mem::size_of::<FlutterLocale>() - 40usize];
    ["Alignment of FlutterLocale"][::std::mem::align_of::<FlutterLocale>() - 8usize];
    ["Offset of field: FlutterLocale::struct_size"]
        [::std::mem::offset_of!(FlutterLocale, struct_size) - 0usize];
    ["Offset of field: FlutterLocale::language_code"]
        [::std::mem::offset_of!(FlutterLocale, language_code) - 8usize];
    ["Offset of field: FlutterLocale::country_code"]
        [::std::mem::offset_of!(FlutterLocale, country_code) - 16usize];
    ["Offset of field: FlutterLocale::script_code"]
        [::std::mem::offset_of!(FlutterLocale, script_code) - 24usize];
    ["Offset of field: FlutterLocale::variant_code"]
        [::std::mem::offset_of!(FlutterLocale, variant_code) - 32usize];
};
#[doc = " Callback that returns the system locale.\n\n Embedders that implement this callback should return the `FlutterLocale`\n from the `supported_locales` list that most closely matches the\n user/device's preferred locale.\n\n This callback does not currently provide the user_data baton.\n https://github.com/flutter/flutter/issues/79826"]
pub type FlutterComputePlatformResolvedLocaleCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut *const FlutterLocale, arg2: usize) -> *const FlutterLocale,
>;
pub const FlutterEngineAOTDataSourceType_kFlutterEngineAOTDataSourceTypeElfPath:
    FlutterEngineAOTDataSourceType = 0;
#[doc = " AOT data source type."]
pub type FlutterEngineAOTDataSourceType = ::std::os::raw::c_int;
#[doc = " This struct specifies one of the various locations the engine can look for\n AOT data sources."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterEngineAOTDataSource {
    pub type_: FlutterEngineAOTDataSourceType,
    pub __bindgen_anon_1: FlutterEngineAOTDataSource__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterEngineAOTDataSource__bindgen_ty_1 {
    #[doc = " Absolute path to an ELF library file."]
    pub elf_path: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineAOTDataSource__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterEngineAOTDataSource__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterEngineAOTDataSource__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterEngineAOTDataSource__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterEngineAOTDataSource__bindgen_ty_1::elf_path"]
        [::std::mem::offset_of!(FlutterEngineAOTDataSource__bindgen_ty_1, elf_path) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineAOTDataSource"]
        [::std::mem::size_of::<FlutterEngineAOTDataSource>() - 16usize];
    ["Alignment of FlutterEngineAOTDataSource"]
        [::std::mem::align_of::<FlutterEngineAOTDataSource>() - 8usize];
    ["Offset of field: FlutterEngineAOTDataSource::type_"]
        [::std::mem::offset_of!(FlutterEngineAOTDataSource, type_) - 0usize];
};
pub type FlutterLogMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterEngineAOTData {
    _unused: [u8; 0],
}
#[doc = " An opaque object that describes the AOT data that can be used to launch a\n FlutterEngine instance in AOT mode."]
pub type FlutterEngineAOTData = *mut _FlutterEngineAOTData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterProjectArgs {
    #[doc = " The size of this struct. Must be sizeof(FlutterProjectArgs)."]
    pub struct_size: usize,
    #[doc = " The path to the Flutter assets directory containing project assets. The\n string can be collected after the call to `FlutterEngineRun` returns. The\n string must be NULL terminated."]
    pub assets_path: *const ::std::os::raw::c_char,
    #[doc = " The path to the Dart file containing the `main` entry point.\n The string can be collected after the call to `FlutterEngineRun` returns.\n The string must be NULL terminated.\n\n @deprecated     As of Dart 2, running from Dart source is no longer\n                 supported. Dart code should now be compiled to kernel form\n                 and will be loaded by from `kernel_blob.bin` in the assets\n                 directory. This struct member is retained for ABI\n                 stability."]
    pub main_path__unused__: *const ::std::os::raw::c_char,
    #[doc = " The path to the `.packages` file for the project. The string can be\n collected after the call to `FlutterEngineRun` returns. The string must be\n NULL terminated.\n\n @deprecated    As of Dart 2, running from Dart source is no longer\n                supported. Dart code should now be compiled to kernel form\n                and will be loaded by from `kernel_blob.bin` in the assets\n                directory. This struct member is retained for ABI\n                stability."]
    pub packages_path__unused__: *const ::std::os::raw::c_char,
    #[doc = " The path to the `icudtl.dat` file for the project. The string can be\n collected after the call to `FlutterEngineRun` returns. The string must\n be NULL terminated."]
    pub icu_data_path: *const ::std::os::raw::c_char,
    #[doc = " The command line argument count used to initialize the project."]
    pub command_line_argc: ::std::os::raw::c_int,
    #[doc = " The command line arguments used to initialize the project. The strings can\n be collected after the call to `FlutterEngineRun` returns. The strings\n must be `NULL` terminated.\n\n @attention     The first item in the command line (if specified at all) is\n                interpreted as the executable name. So if an engine flag\n                needs to be passed into the same, it needs to not be the\n                very first item in the list.\n\n The set of engine flags are only meant to control\n unstable features in the engine. Deployed applications should not pass any\n command line arguments at all as they may affect engine stability at\n runtime in the presence of un-sanitized input. The list of currently\n recognized engine flags and their descriptions can be retrieved from the\n `switches.h` engine source file."]
    pub command_line_argv: *const *const ::std::os::raw::c_char,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to platform messages from the Dart application.\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made. The second parameter, `user_data`, is supplied when\n `FlutterEngineRun` or `FlutterEngineInitialize` is called."]
    pub platform_message_callback: FlutterPlatformMessageCallback,
    #[doc = " The VM snapshot data buffer used in AOT operation. This buffer must be\n mapped in as read-only. For more information refer to the documentation on\n the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub vm_snapshot_data: *const u8,
    #[doc = " The size of the VM snapshot data buffer.  If vm_snapshot_data is a symbol\n reference, 0 may be passed here."]
    pub vm_snapshot_data_size: usize,
    #[doc = " The VM snapshot instructions buffer used in AOT operation. This buffer\n must be mapped in as read-execute. For more information refer to the\n documentation on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub vm_snapshot_instructions: *const u8,
    #[doc = " The size of the VM snapshot instructions buffer. If\n vm_snapshot_instructions is a symbol reference, 0 may be passed here."]
    pub vm_snapshot_instructions_size: usize,
    #[doc = " The isolate snapshot data buffer used in AOT operation. This buffer must\n be mapped in as read-only. For more information refer to the documentation\n on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub isolate_snapshot_data: *const u8,
    #[doc = " The size of the isolate snapshot data buffer.  If isolate_snapshot_data is\n a symbol reference, 0 may be passed here."]
    pub isolate_snapshot_data_size: usize,
    #[doc = " The isolate snapshot instructions buffer used in AOT operation. This\n buffer must be mapped in as read-execute. For more information refer to\n the documentation on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub isolate_snapshot_instructions: *const u8,
    #[doc = " The size of the isolate snapshot instructions buffer. If\n isolate_snapshot_instructions is a symbol reference, 0 may be passed here."]
    pub isolate_snapshot_instructions_size: usize,
    #[doc = " The callback invoked by the engine in root isolate scope. Called\n immediately after the root isolate has been created and marked runnable."]
    pub root_isolate_create_callback: VoidCallback,
    #[doc = " The legacy callback invoked by the engine in order to give the embedder\n the chance to respond to semantics node updates from the Dart application.\n Semantics node updates are sent in batches terminated by a 'batch end'\n callback that is passed a sentinel `FlutterSemanticsNode` whose `id` field\n has the value `kFlutterSemanticsNodeIdBatchEnd`.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                should be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_node_callback: FlutterUpdateSemanticsNodeCallback,
    #[doc = " The legacy callback invoked by the engine in order to give the embedder\n the chance to respond to updates to semantics custom actions from the Dart\n application. Custom action updates are sent in batches terminated by a\n 'batch end' callback that is passed a sentinel\n `FlutterSemanticsCustomAction` whose `id` field has the value\n `kFlutterSemanticsCustomActionIdBatchEnd`.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                should be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_custom_action_callback: FlutterUpdateSemanticsCustomActionCallback,
    #[doc = " Path to a directory used to store data that is cached across runs of a\n Flutter application (such as compiled shader programs used by Skia).\n This is optional.  The string must be NULL terminated.\n"]
    pub persistent_cache_path: *const ::std::os::raw::c_char,
    #[doc = " If true, the engine would only read the existing cache, but not write new\n ones."]
    pub is_persistent_cache_read_only: bool,
    #[doc = " A callback that gets invoked by the engine when it attempts to wait for a\n platform vsync event. The engine will give the platform a baton that needs\n to be returned back to the engine via `FlutterEngineOnVsync`. All batons\n must be retured to the engine before initializing a\n `FlutterEngineShutdown`. Not doing the same will result in a memory leak.\n While the call to `FlutterEngineOnVsync` must occur on the thread that\n made the call to `FlutterEngineRun`, the engine will make this callback on\n an internal engine-managed thread. If the components accessed on the\n embedder are not thread safe, the appropriate re-threading must be done."]
    pub vsync_callback: VsyncCallback,
    #[doc = " The name of a custom Dart entrypoint. This is optional and specifying a\n null or empty entrypoint makes the engine look for a method named \"main\"\n in the root library of the application.\n\n Care must be taken to ensure that the custom entrypoint is not tree-shaken\n away. Usually, this is done using the `@pragma('vm:entry-point')`\n decoration."]
    pub custom_dart_entrypoint: *const ::std::os::raw::c_char,
    #[doc = " Typically the Flutter engine create and manages its internal threads. This\n optional argument allows for the specification of task runner interfaces\n to event loops managed by the embedder on threads it creates."]
    pub custom_task_runners: *const FlutterCustomTaskRunners,
    #[doc = " All `FlutterEngine` instances in the process share the same Dart VM. When\n the first engine is launched, it starts the Dart VM as well. It used to be\n the case that it was not possible to shutdown the Dart VM cleanly and\n start it back up in the process in a safe manner. This issue has since\n been patched. Unfortunately, applications already began to make use of the\n fact that shutting down the Flutter engine instance left a running VM in\n the process. Since a Flutter engine could be launched on any thread,\n applications would \"warm up\" the VM on another thread by launching\n an engine with no isolates and then shutting it down immediately. The main\n Flutter application could then be started on the main thread without\n having to incur the Dart VM startup costs at that time. With the new\n behavior, this \"optimization\" immediately becomes massive performance\n pessimization as the VM would be started up in the \"warm up\" phase, shut\n down there and then started again on the main thread. Changing this\n behavior was deemed to be an unacceptable breaking change. Embedders that\n wish to shutdown the Dart VM when the last engine is terminated in the\n process should opt into this behavior by setting this flag to true."]
    pub shutdown_dart_vm_when_done: bool,
    #[doc = " Typically, Flutter renders the layer hierarchy into a single root surface.\n However, when embedders need to interleave their own contents within the\n Flutter layer hierarchy, their applications can push platform views within\n the Flutter scene. This is done using the `SceneBuilder.addPlatformView`\n call. When this happens, the Flutter rasterizer divides the effective view\n hierarchy into multiple layers. Each layer gets its own backing store and\n Flutter renders into the same. Once the layers contents have been\n fulfilled, the embedder is asked to composite these layers on-screen. At\n this point, it can interleave its own contents within the effective\n hierarchy. The interface for the specification of these layer backing\n stores and the hooks to listen for the composition of layers on-screen can\n be controlled using this field. This field is completely optional. In its\n absence, platforms views in the scene are ignored and Flutter renders to\n the root surface as normal."]
    pub compositor: *const FlutterCompositor,
    #[doc = " Max size of the old gen heap for the Dart VM in MB, or 0 for unlimited, -1\n for default value.\n\n See also:\n https://github.com/dart-lang/sdk/blob/ca64509108b3e7219c50d6c52877c85ab6a35ff2/runtime/vm/flag_list.h#L150"]
    pub dart_old_gen_heap_size: i64,
    #[doc = " The AOT data to be used in AOT operation.\n\n Embedders should instantiate and destroy this object via the\n FlutterEngineCreateAOTData and FlutterEngineCollectAOTData methods.\n\n Embedders can provide either snapshot buffers or aot_data, but not both."]
    pub aot_data: FlutterEngineAOTData,
    #[doc = " A callback that computes the locale the platform would natively resolve\n to.\n\n The input parameter is an array of FlutterLocales which represent the\n locales supported by the app. One of the input supported locales should\n be selected and returned to best match with the user/device's preferred\n locale. The implementation should produce a result that as closely\n matches what the platform would natively resolve to as possible."]
    pub compute_platform_resolved_locale_callback: FlutterComputePlatformResolvedLocaleCallback,
    #[doc = " The command line argument count for arguments passed through to the Dart\n entrypoint."]
    pub dart_entrypoint_argc: ::std::os::raw::c_int,
    #[doc = " The command line arguments passed through to the Dart entrypoint. The\n strings must be `NULL` terminated.\n\n The strings will be copied out and so any strings passed in here can\n be safely collected after initializing the engine with\n `FlutterProjectArgs`."]
    pub dart_entrypoint_argv: *const *const ::std::os::raw::c_char,
    pub log_message_callback: FlutterLogMessageCallback,
    pub log_tag: *const ::std::os::raw::c_char,
    pub on_pre_engine_restart_callback: OnPreEngineRestartCallback,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to updates to semantics nodes and custom actions from\n the Dart application.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                must be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_callback: FlutterUpdateSemanticsCallback,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to updates to semantics nodes and custom actions from\n the Dart application.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n Only one of `update_semantics_node_callback`, `update_semantics_callback`,\n and `update_semantics_callback2` may be provided; the others must be set\n to null."]
    pub update_semantics_callback2: FlutterUpdateSemanticsCallback2,
    #[doc = " The callback invoked by the engine in response to a channel listener\n being registered on the framework side. The callback is invoked from\n a task posted to the platform thread."]
    pub channel_update_callback: FlutterChannelUpdateCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterProjectArgs"][::std::mem::size_of::<FlutterProjectArgs>() - 296usize];
    ["Alignment of FlutterProjectArgs"][::std::mem::align_of::<FlutterProjectArgs>() - 8usize];
    ["Offset of field: FlutterProjectArgs::struct_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, struct_size) - 0usize];
    ["Offset of field: FlutterProjectArgs::assets_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, assets_path) - 8usize];
    ["Offset of field: FlutterProjectArgs::main_path__unused__"]
        [::std::mem::offset_of!(FlutterProjectArgs, main_path__unused__) - 16usize];
    ["Offset of field: FlutterProjectArgs::packages_path__unused__"]
        [::std::mem::offset_of!(FlutterProjectArgs, packages_path__unused__) - 24usize];
    ["Offset of field: FlutterProjectArgs::icu_data_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, icu_data_path) - 32usize];
    ["Offset of field: FlutterProjectArgs::command_line_argc"]
        [::std::mem::offset_of!(FlutterProjectArgs, command_line_argc) - 40usize];
    ["Offset of field: FlutterProjectArgs::command_line_argv"]
        [::std::mem::offset_of!(FlutterProjectArgs, command_line_argv) - 48usize];
    ["Offset of field: FlutterProjectArgs::platform_message_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, platform_message_callback) - 56usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_data) - 64usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_data_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_data_size) - 72usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_instructions"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_instructions) - 80usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_instructions_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_instructions_size) - 88usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_data) - 96usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_data_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_data_size) - 104usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_instructions"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_instructions) - 112usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_instructions_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_instructions_size) - 120usize];
    ["Offset of field: FlutterProjectArgs::root_isolate_create_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, root_isolate_create_callback) - 128usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_node_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_node_callback) - 136usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_custom_action_callback"][::std::mem::offset_of!(
        FlutterProjectArgs,
        update_semantics_custom_action_callback
    ) - 144usize];
    ["Offset of field: FlutterProjectArgs::persistent_cache_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, persistent_cache_path) - 152usize];
    ["Offset of field: FlutterProjectArgs::is_persistent_cache_read_only"]
        [::std::mem::offset_of!(FlutterProjectArgs, is_persistent_cache_read_only) - 160usize];
    ["Offset of field: FlutterProjectArgs::vsync_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, vsync_callback) - 168usize];
    ["Offset of field: FlutterProjectArgs::custom_dart_entrypoint"]
        [::std::mem::offset_of!(FlutterProjectArgs, custom_dart_entrypoint) - 176usize];
    ["Offset of field: FlutterProjectArgs::custom_task_runners"]
        [::std::mem::offset_of!(FlutterProjectArgs, custom_task_runners) - 184usize];
    ["Offset of field: FlutterProjectArgs::shutdown_dart_vm_when_done"]
        [::std::mem::offset_of!(FlutterProjectArgs, shutdown_dart_vm_when_done) - 192usize];
    ["Offset of field: FlutterProjectArgs::compositor"]
        [::std::mem::offset_of!(FlutterProjectArgs, compositor) - 200usize];
    ["Offset of field: FlutterProjectArgs::dart_old_gen_heap_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_old_gen_heap_size) - 208usize];
    ["Offset of field: FlutterProjectArgs::aot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, aot_data) - 216usize];
    ["Offset of field: FlutterProjectArgs::compute_platform_resolved_locale_callback"][::std::mem::offset_of!(
        FlutterProjectArgs,
        compute_platform_resolved_locale_callback
    )
        - 224usize];
    ["Offset of field: FlutterProjectArgs::dart_entrypoint_argc"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_entrypoint_argc) - 232usize];
    ["Offset of field: FlutterProjectArgs::dart_entrypoint_argv"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_entrypoint_argv) - 240usize];
    ["Offset of field: FlutterProjectArgs::log_message_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, log_message_callback) - 248usize];
    ["Offset of field: FlutterProjectArgs::log_tag"]
        [::std::mem::offset_of!(FlutterProjectArgs, log_tag) - 256usize];
    ["Offset of field: FlutterProjectArgs::on_pre_engine_restart_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, on_pre_engine_restart_callback) - 264usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_callback) - 272usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_callback2"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_callback2) - 280usize];
    ["Offset of field: FlutterProjectArgs::channel_update_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, channel_update_callback) - 288usize];
};
unsafe extern "C" {
    #[doc = " @brief      Creates the necessary data structures to launch a Flutter Dart\n             application in AOT mode. The data may only be collected after\n             all FlutterEngine instances launched using this data have been\n             terminated.\n\n @param[in]  source    The source of the AOT data.\n @param[out] data_out  The AOT data on success. Unchanged on failure.\n\n @return     Returns if the AOT data could be successfully resolved.\n"]
    pub fn FlutterEngineCreateAOTData(
        source: *const FlutterEngineAOTDataSource,
        data_out: *mut FlutterEngineAOTData,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Initialize and run a Flutter engine instance and return a handle\n             to it. This is a convenience method for the pair of calls to\n             `FlutterEngineInitialize` and `FlutterEngineRunInitialized`.\n\n @note       This method of running a Flutter engine works well except in\n             cases where the embedder specifies custom task runners via\n             `FlutterProjectArgs::custom_task_runners`. In such cases, the\n             engine may need the embedder to post tasks back to it before\n             `FlutterEngineRun` has returned. Embedders can only post tasks\n             to the engine if they have a handle to the engine. In such\n             cases, embedders are advised to get the engine handle via the\n             `FlutterInitializeCall`. Then they can call\n             `FlutterEngineRunInitialized` knowing that they will be able to\n             service custom tasks on other threads with the engine handle.\n\n @param[in]  version    The Flutter embedder API version. Must be\n                        FLUTTER_ENGINE_VERSION.\n @param[in]  config     The renderer configuration.\n @param[in]  args       The Flutter project arguments.\n @param      user_data  A user data baton passed back to embedders in\n                        callbacks.\n @param[out] engine_out The engine handle on successful engine creation.\n\n @return     The result of the call to run the Flutter engine.\n"]
    pub fn FlutterEngineRun(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Shuts down a Flutter engine instance. The engine handle is no\n             longer valid for any calls in the embedder API after this point.\n             Making additional calls with this handle is undefined behavior.\n\n @note       This de-initializes the Flutter engine instance (via an implicit\n             call to `FlutterEngineDeinitialize`) if necessary.\n\n @param[in]  engine  The Flutter engine instance to collect.\n\n @return     The result of the call to shutdown the Flutter engine instance.\n"]
    pub fn FlutterEngineShutdown(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Initialize a Flutter engine instance. This does not run the\n             Flutter application code till the `FlutterEngineRunInitialized`\n             call is made. Besides Flutter application code, no tasks are\n             scheduled on embedder managed task runners either. This allows\n             embedders providing custom task runners to the Flutter engine to\n             obtain a handle to the Flutter engine before the engine can post\n             tasks on these task runners.\n\n @param[in]  version    The Flutter embedder API version. Must be\n                        FLUTTER_ENGINE_VERSION.\n @param[in]  config     The renderer configuration.\n @param[in]  args       The Flutter project arguments.\n @param      user_data  A user data baton passed back to embedders in\n                        callbacks.\n @param[out] engine_out The engine handle on successful engine creation.\n\n @return     The result of the call to initialize the Flutter engine.\n"]
    pub fn FlutterEngineInitialize(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Stops running the Flutter engine instance. After this call, the\n             embedder is also guaranteed that no more calls to post tasks\n             onto custom task runners specified by the embedder are made. The\n             Flutter engine handle still needs to be collected via a call to\n             `FlutterEngineShutdown`.\n\n @param[in]  engine    The running engine instance to de-initialize.\n\n @return     The result of the call to de-initialize the Flutter engine.\n"]
    pub fn FlutterEngineDeinitialize(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Runs an initialized engine instance. An engine can be\n             initialized via `FlutterEngineInitialize`. An initialized\n             instance can only be run once. During and after this call,\n             custom task runners supplied by the embedder are expected to\n             start servicing tasks.\n\n @param[in]  engine  An initialized engine instance that has not previously\n                     been run.\n\n @return     The result of the call to run the initialized Flutter\n             engine instance.\n"]
    pub fn FlutterEngineRunInitialized(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendWindowMetricsEvent(
        engine: FlutterEngine,
        event: *const FlutterWindowMetricsEvent,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendPointerEvent(
        engine: FlutterEngine,
        events: *const FlutterPointerEvent,
        events_count: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Sends a key event to the engine. The framework will decide\n             whether to handle this event in a synchronous fashion, although\n             due to technical limitation, the result is always reported\n             asynchronously. The `callback` is guaranteed to be called\n             exactly once.\n\n @param[in]  engine         A running engine instance.\n @param[in]  event          The event data to be sent. This function will no\n                            longer access `event` after returning.\n @param[in]  callback       The callback invoked by the engine when the\n                            Flutter application has decided whether it\n                            handles this event. Accepts nullptr.\n @param[in]  user_data      The context associated with the callback. The\n                            exact same value will used to invoke `callback`.\n                            Accepts nullptr.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineSendKeyEvent(
        engine: FlutterEngine,
        event: *const FlutterKeyEvent,
        callback: FlutterKeyEventCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendPlatformMessage(
        engine: FlutterEngine,
        message: *const FlutterPlatformMessage,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief     Creates a platform message response handle that allows the\n            embedder to set a native callback for a response to a message.\n            This handle may be set on the `response_handle` field of any\n            `FlutterPlatformMessage` sent to the engine.\n\n            The handle must be collected via a call to\n            `FlutterPlatformMessageReleaseResponseHandle`. This may be done\n            immediately after a call to `FlutterEngineSendPlatformMessage`\n            with a platform message whose response handle contains the handle\n            created using this call. In case a handle is created but never\n            sent in a message, the release call must still be made. Not\n            calling release on the handle results in a small memory leak.\n\n            The user data baton passed to the data callback is the one\n            specified in this call as the third argument.\n\n @see       FlutterPlatformMessageReleaseResponseHandle()\n\n @param[in]  engine         A running engine instance.\n @param[in]  data_callback  The callback invoked by the engine when the\n                            Flutter application send a response on the\n                            handle.\n @param[in]  user_data      The user data associated with the data callback.\n @param[out] response_out   The response handle created when this call is\n                            successful.\n\n @return     The result of the call.\n"]
    pub fn FlutterPlatformMessageCreateResponseHandle(
        engine: FlutterEngine,
        data_callback: FlutterDataCallback,
        user_data: *mut ::std::os::raw::c_void,
        response_out: *mut *mut FlutterPlatformMessageResponseHandle,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Send a response from the native side to a platform message from\n             the Dart Flutter application.\n\n @param[in]  engine       The running engine instance.\n @param[in]  handle       The platform message response handle.\n @param[in]  data         The data to associate with the platform message\n                          response.\n @param[in]  data_length  The length of the platform message response data.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineSendPlatformMessageResponse(
        engine: FlutterEngine,
        handle: *const FlutterPlatformMessageResponseHandle,
        data: *const u8,
        data_length: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Enable or disable accessibility semantics.\n\n @param[in]  engine     A running engine instance.\n @param[in]  enabled    When enabled, changes to the semantic contents of the\n                        window are sent via the\n                        `FlutterUpdateSemanticsCallback2` registered to\n                        `update_semantics_callback2` in\n                        `FlutterProjectArgs`.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineUpdateSemanticsEnabled(
        engine: FlutterEngine,
        enabled: bool,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Notify the engine that a vsync event occurred. A baton passed to\n             the platform via the vsync callback must be returned. This call\n             must be made on the thread on which the call to\n             `FlutterEngineRun` was made.\n\n @see        FlutterEngineGetCurrentTime()\n\n @attention  That frame timepoints are in nanoseconds.\n\n @attention  The system monotonic clock is used as the timebase.\n\n @param[in]  engine.                  A running engine instance.\n @param[in]  baton                    The baton supplied by the engine.\n @param[in]  frame_start_time_nanos   The point at which the vsync event\n                                      occurred or will occur. If the time\n                                      point is in the future, the engine will\n                                      wait till that point to begin its frame\n                                      workload.\n @param[in]  frame_target_time_nanos  The point at which the embedder\n                                      anticipates the next vsync to occur.\n                                      This is a hint the engine uses to\n                                      schedule Dart VM garbage collection in\n                                      periods in which the various threads\n                                      are most likely to be idle. For\n                                      example, for a 60Hz display, embedders\n                                      should add 16.6 * 1e6 to the frame time\n                                      field.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineOnVsync(
        engine: FlutterEngine,
        baton: isize,
        frame_start_time_nanos: u64,
        frame_target_time_nanos: u64,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Get the current time in nanoseconds from the clock used by the\n             flutter engine. This is the system monotonic clock.\n\n @return     The current time in nanoseconds.\n"]
    pub fn FlutterEngineGetCurrentTime() -> u64;
}
unsafe extern "C" {
    #[doc = " @brief      Inform the engine to run the specified task. This task has been\n             given to the engine via the\n             `FlutterTaskRunnerDescription.post_task_callback`. This call\n             must only be made at the target time specified in that callback.\n             Running the task before that time is undefined behavior.\n\n @param[in]  engine     A running engine instance.\n @param[in]  task       the task handle.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineRunTask(
        engine: FlutterEngine,
        task: *const FlutterTask,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Schedule a new frame to redraw the content.\n\n @param[in]  engine     A running engine instance.\n\n @return the result of the call made to the engine.\n"]
    pub fn FlutterEngineScheduleFrame(engine: FlutterEngine) -> FlutterEngineResult;
}
